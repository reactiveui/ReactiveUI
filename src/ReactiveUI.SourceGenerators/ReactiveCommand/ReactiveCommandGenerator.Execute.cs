// Copyright (c) 2024 .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System;
using System.CodeDom.Compiler;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ReactiveUI.SourceGenerators.Extensions;
using ReactiveUI.SourceGenerators.Helpers;
using ReactiveUI.SourceGenerators.Input.Models;
using ReactiveUI.SourceGenerators.Models;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace ReactiveUI.SourceGenerators;

/// <summary>
/// ReactiveCommandGenerator.
/// </summary>
/// <seealso cref="Microsoft.CodeAnalysis.IIncrementalGenerator" />
public partial class ReactiveCommandGenerator
{
    private const string RxCmd = "ReactiveUI.ReactiveCommand";
    private const string RxCmdAttribute = "ReactiveUI.SourceGenerators.ReactiveCommandAttribute";
    private const string RxCmdProp = "Command { get; private set; }";

    /// <summary>
    /// A container for all the logic for <see cref="ReactiveCommandGenerator"/>.
    /// </summary>
    internal static class Execute
    {
        /// <summary>
        /// Creates the <see cref="MemberDeclarationSyntax"/> instances for a specified command.
        /// </summary>
        /// <param name="commandInfo">The input <see cref="CommandInfo"/> instance with the info to generate the command.</param>
        /// <returns>The <see cref="CompilationUnitSyntax"/> instances for the ReactiveCommand.</returns>
        internal static CompilationUnitSyntax GetSyntax(CommandInfo commandInfo)
        {
            // TODO: Complete the logic to generate the full command syntax
            var code = CompilationUnit().AddMembers(
                NamespaceDeclaration(IdentifierName(commandInfo.ClassNamespace))
                .WithLeadingTrivia(TriviaList(
                    Comment("// <auto-generated/>"),
                    Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
                    Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))))
                .AddMembers(
                    ClassDeclaration(commandInfo.ClassName)
                    .AddModifiers([.. commandInfo.DeclarationSyntax.Modifiers])))
                .AddMembers().NormalizeWhitespace().ToFullString();

            // Remove the last 4 characters to remove the closing brackets
            var baseCode = code.Remove(code.Length - 4);

            // Prepare all necessary type names with type arguments
            using var stringStream = new StringWriter();
            using var writer = new IndentedTextWriter(stringStream, "\t");
            writer.WriteLine(baseCode);
            writer.Indent++;
            if (commandInfo.DeclarationSyntax.TypeParameterList != null)
            {
                writer.WriteLine($"{commandInfo.DeclarationSyntax.TypeParameterList}");
            }

            if (commandInfo.DeclarationSyntax.ConstraintClauses.Count > 0)
            {
                writer.WriteLine($"{commandInfo.DeclarationSyntax.ConstraintClauses}");
            }

            writer.Indent++;

            // Add the command properties
            foreach (var commandExtensionInfo in commandInfo.CommandExtensionInfos)
            {
                var outputType = commandExtensionInfo.GetOutputTypeText();
                var inputType = commandExtensionInfo.GetInputTypeText();
                writer.WriteLine($"{Token(SyntaxKind.PublicKeyword)} {RxCmd}<{inputType}, {outputType}>? {commandExtensionInfo.MethodName}{RxCmdProp}");
            }

            writer.WriteLine();
            writer.WriteLine($"{Token(SyntaxKind.ProtectedKeyword)} {Token(SyntaxKind.VoidKeyword)} InitializeCommands()");
            writer.WriteLine(Token(SyntaxKind.OpenBraceToken));
            writer.Indent++;

            // Add the command initialization
            foreach (var commandExtensionInfo in commandInfo.CommandExtensionInfos)
            {
                var commandName = $"{commandExtensionInfo.MethodName}Command";
                var outputType = commandExtensionInfo.GetOutputTypeText();
                var inputType = commandExtensionInfo.GetInputTypeText();
                if (commandExtensionInfo.ArgumentType == null)
                {
                    if (commandExtensionInfo.IsObservable)
                    {
                        writer.WriteLine($"{commandName} = {RxCmd}.CreateFromObservable({commandExtensionInfo.MethodName});");
                    }
                    else if (commandExtensionInfo.IsTask)
                    {
                        writer.WriteLine($"{commandName} = {RxCmd}.CreateFromTask({commandExtensionInfo.MethodName});");
                    }
                    else
                    {
                        writer.WriteLine($"{commandName} = {RxCmd}.Create({commandExtensionInfo.MethodName});");
                    }
                }
                else if (commandExtensionInfo.ArgumentType != null && !commandExtensionInfo.IsReturnTypeVoid)
                {
                    if (commandExtensionInfo.IsObservable)
                    {
                        writer.WriteLine($"{commandName} = {RxCmd}.CreateFromObservable<{inputType}, {outputType}>({commandExtensionInfo.MethodName});");
                    }
                    else if (commandExtensionInfo.IsTask)
                    {
                        writer.WriteLine($"{commandName} = {RxCmd}.CreateFromTask<{inputType}, {outputType}>({commandExtensionInfo.MethodName});");
                    }
                    else
                    {
                        writer.WriteLine($"{commandName} = {RxCmd}.Create<{inputType}, {outputType}>({commandExtensionInfo.MethodName});");
                    }
                }
                else if (commandExtensionInfo.ArgumentType != null && commandExtensionInfo.IsReturnTypeVoid)
                {
                    writer.WriteLine(!commandExtensionInfo.IsTask
                        ? $"{commandName} = {RxCmd}.Create<{inputType}>({commandExtensionInfo.MethodName});"
                        : $"{commandName} = {RxCmd}.CreateFromTask<{inputType}>({commandExtensionInfo.MethodName});");
                }
            }

            writer.Indent--;
            writer.WriteLine(Token(SyntaxKind.CloseBraceToken));
            writer.Indent--;
            writer.WriteLine(Token(SyntaxKind.CloseBraceToken));
            writer.Indent--;
            writer.WriteLine(Token(SyntaxKind.CloseBraceToken));
            var output = stringStream.ToString();
            return ParseCompilationUnit(output).NormalizeWhitespace();
        }

        internal static void GetCommandInfoFromClass(ImmutableArrayBuilder<HierarchyInfo> hierarchys, Compilation compilation, SemanticModel semanticModel, ClassDeclarationSyntax declaredClass, out CommandInfo? commandInfo)
        {
            var classSymbol = ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass) as INamedTypeSymbol;
            var classNamespace = classSymbol?.ContainingNamespace.ToString();
            var typeName = declaredClass.Identifier.ValueText;

            var methodMembers = declaredClass.Members
                .OfType<MethodDeclarationSyntax>()
                .ToList();

            using var commandExtensionInfos = ImmutableArrayBuilder<CommandExtensionInfo>.Rent();
            foreach (var methodSyntax in methodMembers)
            {
                var symbol = ModelExtensions.GetDeclaredSymbol(semanticModel, methodSyntax)!;

                // Skip symbols without the target attribute
                if (!symbol.TryGetAttributeWithFullyQualifiedMetadataName(RxCmdAttribute, out var attributeData))
                {
                    continue;
                }

                if (attributeData != null)
                {
                    var methodSymbol = (IMethodSymbol)symbol!;
                    var isTask = IsTaskReturnType(methodSymbol.ReturnType);
                    var isObservable = IsObservableReturnType(methodSymbol.ReturnType);
                    var realReturnType = isTask || isObservable ? GetTaskReturnType(compilation, methodSymbol.ReturnType) : methodSymbol.ReturnType;
                    var isReturnTypeVoid = SymbolEqualityComparer.Default.Equals(realReturnType, compilation.GetSpecialType(SpecialType.System_Void));
                    var methodParameters = methodSymbol.Parameters.ToList();
                    if (methodParameters.Count > 1)
                    {
                        continue; // Too many parameters, continue
                    }

                    // Get the hierarchy info for the target symbol, and try to gather the command info
                    hierarchys.Add(HierarchyInfo.From(methodSymbol.ContainingType));

                    commandExtensionInfos.Add(new(
                        methodSymbol.Name,
                        realReturnType,
                        methodParameters.SingleOrDefault()?.Type,
                        isTask,
                        isReturnTypeVoid,
                        isObservable));
                }
            }

            commandInfo = new CommandInfo(
                classNamespace!,
                typeName,
                declaredClass,
                commandExtensionInfos.ToImmutable());
        }

        private static bool IsTaskReturnType(ITypeSymbol? typeSymbol)
        {
            var nameFormat = SymbolDisplayFormat.FullyQualifiedFormat;
            do
            {
                var typeName = typeSymbol?.ToDisplayString(nameFormat);
                if (typeName == "global::System.Threading.Tasks.Task")
                {
                    return true;
                }

                typeSymbol = typeSymbol?.BaseType;
            }
            while (typeSymbol != null);

            return false;
        }

        private static bool IsObservableReturnType(ITypeSymbol? typeSymbol)
        {
            var nameFormat = SymbolDisplayFormat.FullyQualifiedFormat;
            do
            {
                var typeName = typeSymbol?.ToDisplayString(nameFormat);
                if (typeName?.Contains("global::System.IObservable") == true)
                {
                    return true;
                }

                typeSymbol = typeSymbol?.BaseType;
            }
            while (typeSymbol != null);

            return false;
        }

        private static ITypeSymbol GetTaskReturnType(Compilation compilation, ITypeSymbol typeSymbol) => typeSymbol switch
        {
            INamedTypeSymbol { TypeArguments.Length: 1 } namedTypeSymbol => namedTypeSymbol.TypeArguments[0],
            _ => compilation.GetSpecialType(SpecialType.System_Void)
        };
    }
}
