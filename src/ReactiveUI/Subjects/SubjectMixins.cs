using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reactive;
using System.Reactive.Concurrency;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Text;

namespace ReactiveUI.Subjects
{
    public static class SubjectMixins
    {
        /// <summary>
        /// Generate a subject from an INPC property
        /// </summary>
        /// <param name="This"></param>
        /// <param name="property">selector expression to detect the property</param>
        /// <param name="debounce">Prevent the property subject bouncing a set value back to the sender.</param>
        public static ISubject<TValue> PropertySubject<TObject, TValue>
            ( this TObject This
            , Expression<Func<TObject, TValue>> property
            , bool debounce = true
            )
            where TObject : class
        {
            if (This == null) throw new ArgumentNullException(nameof(This));
            if (property == null) throw new ArgumentNullException(nameof(property));

            var debounceFlag = false;
            var o = This.WhenAnyValue(property).Retry().Where(_=>!debounceFlag);

            var propertyExpression = Reflection.Rewrite(property.Body);
            var oo = Observer.Create<TValue>
                (x =>
                {
                    debounceFlag = debounce;
                        Reflection.TrySetValueToPropertyChain
                            (This, propertyExpression.GetExpressionChain(), x);
                    debounceFlag = false;
                }); 

            return new TransformerSubject<TValue>(oo, o);
        }



        /// <summary>
        /// Flatten a sequence of subjects into a single subject. Subscribing
        /// to the output will receive data from the current subject then it
        /// will receive data from the next subject when the switch occurs.
        /// 
        /// Calling OnNext on the output subject will cause the current subject
        /// to receive the OnNext call. When the switch occurs the next subject
        /// will receive the data on a call to OnNext.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="This"></param>
        /// <returns></returns>
        public static ISubject<T> Switch<T>
            (this IObservable<ISubject<T>> This)
        {
            var o = ((IObservable<IObservable<T>>)This).Switch();
            var oo = ((IObservable<IObserver<T>>)This).Switch();
            return new TransformerSubject<T>(oo, o);
        }


        /// <summary>
        /// Calling OnNext on the return observer will call OnNext on whichever
        /// is the latest observer generated by the observable sequence.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="source"></param>
        /// <returns></returns>
        public static IObserver<T> Switch<T>(this IObservable<IObserver<T>> source)
        {
            var current = Observer.Create<T>(x => { });
            var subscription = source.Subscribe(o =>
            {
                // replace with new observer before we complete the old one
                lock ( source )
                {
                    current.OnCompleted();
                    current = o;
                }
            });

            return Observer.Create<T>(
                onNext: v => current.OnNext(v),
                onCompleted: () =>
                {
                    lock ( source )
                    {
                        subscription.Dispose();
                        current.OnCompleted();
                    }
                },
                onError: e =>
                {
                    lock ( source )
                    {
                        subscription.Dispose();
                        current.OnError(e);
                    }
                });
        }


        /// <summary>
        /// Given a dynamic converter provided by the constraintGenerator
        /// and updated by 'u' the observable generate a Subject which always
        /// converts it's values using the latest converter.
        /// </summary>
        /// <typeparam name="TSource"></typeparam>
        /// <typeparam name="TTarget"></typeparam>
        /// <typeparam name="TU"></typeparam>
        /// <param name="This"></param>
        /// <param name="u"></param>
        /// <param name="constraintGenerator"></param>
        /// <param name="catchWith"></param>
        /// <returns></returns>
        public static ISubject<TTarget> CombineLatest<TSource,TTarget,TU>
            ( this ISubject<TSource> This
            , IObservable<TU> u
            , Func<TU, TwoWayConverter<TSource, TTarget>> constraintGenerator
            , IObserver<Option<Exception>> catchWith 
            )
        {
            return u.Select(v => This.Select( constraintGenerator (v), catchWith)).Switch();
        }

        /// <summary>
        /// Convert the subject using the converter
        /// </summary>
        public static ISubject<TTarget> Select<TSource, TTarget>
            ( this ISubject<TSource> This
            , TwoWayConverter<TSource, TTarget> converter
            , IObserver<Option<Exception>> catchWith 
            )
        {
            if (catchWith==null)
            {
                catchWith = Observer.Create<Option<Exception>>( e=>e.IfSome( v => throw v ) );
            }

            return This.Select
                ( rightToLeft: converter.ConvertTo
                , leftToRight: converter.ConvertFrom
                , catchWith: catchWith);
        }



        ///  <summary>
        ///  Transform a subject with two functions
        ///  that convert from or to the wrapped type
        ///  of the subject.
        /// 
        ///  If convertTo fails then the optional catchWith
        ///  observer is notified with <![CDATA[Maybe.Some<Exception>()]]>
        ///  
        ///  If convertTo passes without exception catchWith
        ///  observer is notified with <![CDATA[Maybe.None<Exception>()]]>
        /// 
        ///  leftToRight is always assumed to pass as this is not
        ///  dependant on user input. The catchWith observer is
        ///  always notified with <![CDATA[Maybe.None<Exception>()]]> whenever
        ///  leftToRight is called.
        ///  
        ///  It is assumed that leftToRight will always
        ///  work.
        ///  </summary>
        /// <param name="this"></param>
        /// <param name="rightToLeft"></param>
        /// <param name="leftToRight"></param>
        ///  <param name="catchWith"></param>
        ///  <returns></returns>
        public static ISubject<TR>
            Select<T, TR>
            ( this ISubject<T> @this
            , Func<TR, T> rightToLeft
            , Func<T, TR> leftToRight
            , Action<Option<Exception>> catchWith
            )
        {
            return @this.Select(rightToLeft, leftToRight, Observer.Create(catchWith));
        }

        public static ISubject<TR>
            Select<T, TR>
            ( this ISubject<T> @this
            , IObservable<Func<TR, T>> rightToLeft
            , IObservable<Func<T, TR>> leftToRight
            , IObserver<Option<Exception>> catchWith
            )
        {
            var subjectStream = Observable
                .CombineLatest
                ( rightToLeft
                , leftToRight
                , ( r, l ) =>  @this.Select(r, l, catchWith) );

            return subjectStream.Switch();
        }

        public static ISubject<TR> Select<T, TR>
            ( this ISubject<T> This
            , Func<TR, T> rightToLeft
            , Func<T, TR> leftToRight
            , IObserver<Option<Exception>> catchWith
            )
        {
            Debug.Assert(catchWith != null);

            // catchWith is always notified with Prelude.None
            // if the leftToRight passes ( which it is assumed to do).
            // This will reset any error state due to an error in
            // user input coming from the opposite direction.
            var observable = This
                .Select(leftToRight);

            var observer = Observer.Create<TR>(
                onNext: x =>
                {
                    try
                    {
                        var v = rightToLeft(x);
                        // catchWith.onNext *must* be called before
                        // This.onNext. If multiple error handlers
                        // are registered then the deepest error
                        // handler should be called last so that
                        // the final state is an error. For example
                        // we might have a parsing stage then a 
                        // validation stage. The parsing stage might
                        // pass and then a Maybe.None<Exception()>
                        // is passed to catchWith to signal success
                        // but then a validation stage might fail.

                        // If the following calls were in the opposite
                        // order then there would be a Maybe.None<Exception()>
                        // sent *after* the deeper Maybe.Some<Exception()> 
                        // which would clear the error state of the
                        // code registered to handle the error state.
                        catchWith.OnNext(Option.None);
                        This.OnNext(v);
                    }
                    catch (Exception e)
                    {
                        catchWith.OnNext(e.Some());
                    }
                },
                onError: This.OnError);

            return new TransformerSubject<TR>(observer, observable);

        }

        /// <summary>
        /// Creates a two way binding from a subject to a view property.
        /// It does not perform conversions.
        /// </summary>
        public static IDisposable TwoWayBindTo<TView, TValue>
            ( this ISubject<TValue> model
            , TView view
            , Expression<Func<TView, TValue>> viewProperty
            , Func<TValue,bool> validateRight = null
            , IScheduler scheduler = null
            , IObservable<Option<IObservable<Unit>>> updateViewOn = null 
            , IObservable<Option<IObservable<Unit>>> updateModelOn = null 
            )
            where TView : class
        {
            validateRight = validateRight ?? (t=>true);

            return model.TwoWayBindTo
                ( view.PropertySubject
                      ( viewProperty )
                  , validateRight
                  , scheduler
                  , updateViewOn
                  , updateModelOn );
        }



        /// <summary>
        /// Sample the incoming observable or take everything. Only
        /// subscribes to the underlying observable once. If the option
        /// is none then the source observable is passed through.
        /// If the option holds an <![CDATA[IObservable<Unit>]]> then
        /// the source observable is sampled with it.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="this"></param>
        /// <param name="sampleObservableMaybeObservable"></param>
        /// <returns></returns>
        public static IObservable<T> SampleOrAll<T>(
            this IObservable<T> @this
            , IObservable<Option<IObservable<Unit>>> sampleObservableMaybeObservable  )
        {
            return Observable.Create<T>(observer =>
            {
                var s = new ReplaySubject<T>();
                var d0 = sampleObservableMaybeObservable
                    .StartWith(Option<IObservable<Unit>>.None  ) // Take all values
                    .Select(sampleObservableMaybe => sampleObservableMaybe.Select( sampleObservable => s.Sample(sampleObservable) ).IfNone( s ))
                    .Switch()
                    .Subscribe(observer.OnNext);
                var d1 = @this.Subscribe(v => s.OnNext(v));
                return new CompositeDisposable(d0,d1);
            });
        }



#if NET_45
        /// <summary>
        /// Use standard converters to convert the types from
        /// the source subject to target subject
        /// </summary>
        /// <typeparam name="TSource"></typeparam>
        /// <typeparam name="TTarget"></typeparam>
        /// <param name="subject"></param>
        /// <param name="catchWith"></param>
        /// <returns></returns>
        public static ISubject<TTarget> Convert<TSource, TTarget>
            ( this ISubject<TSource> subject
            , IObserver<Option<Exception>> catchWith)
        {

            var targetType = typeof(TTarget);
            var sourceType = typeof(TSource);

            Converters<TSource, TTarget>(targetType, sourceType, out var sourceToTarget, out var targetToSource);

            return subject.Select
                ( rightToLeft: targetToSource
                , leftToRight: sourceToTarget
                , catchWith: catchWith
                );
        }

        public class ConversionException : Exception
        {
            public object ConversionSource { get; }
            public Type TargetType { get; }

            public ConversionException(object conversionSource, Type targetType) : base($"{conversionSource} is invalid for {targetType.Name}")
            {
                ConversionSource = conversionSource;
                TargetType = targetType;
            }
        }

        [DebuggerNonUserCode]
        public static void Converters<TSource, TTarget>
            (Type targetType, Type sourceType, out Func<TSource, TTarget> sourceToTarget, out Func<TTarget, TSource> targetToSource)
        {
            var converter = new ComponentModelTypeConverter();

            sourceToTarget = source =>
            {
                if (!converter.TryConvert(source, typeof(TTarget), null, out var result))
                {
                    throw new ConversionException(source, typeof(TTarget));
                }
                return (TTarget) result;
            };

            targetToSource = target =>
            {
                if (!converter.TryConvert(target, typeof(TSource), null, out var result))
                {
                    throw new ConversionException(target, typeof(TSource));
                }
                return (TSource) result;

            };

        }
#endif

        /// <summary>
        /// Bind a subject on the left to a subject on the right. It is possible
        /// to supply a validation function to validate the state of the right hand
        /// side.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="modelSubject"></param>
        /// <param name="viewSubject"></param>
        /// <param name="validateView">Perform a validation on the right hand side. If it fails values
        ///     will not be passed from right to left. 
        /// 
        ///     When a value is passed from left to right the validation is executed after the transfer
        /// </param>
        /// <param name="scheduler"></param>
        /// <param name="updateViewOn"></param>
        /// <param name="updateModelOn"></param>
        /// <returns></returns>
        public static IDisposable TwoWayBindTo<T>
            ( this ISubject<T> modelSubject
            , ISubject<T> viewSubject
            , Func<T, bool> validateView = null
            , IScheduler scheduler = null
            , IObservable<Option<IObservable<Unit>>> updateViewOn = null
            , IObservable<Option<IObservable<Unit>>> updateModelOn = null
            )
        {
            // Implement two way binding between the subjects with debounce
            // code
            validateView = validateView ?? (t=>true);
            scheduler = scheduler ?? RxApp.MainThreadScheduler;

            var enableView = new Subject<Unit>();

            IObservable<T> viewObserver = viewSubject;

            viewObserver = updateModelOn !=null ? viewObserver.SampleOrAll(updateModelOn) : viewObserver;

            // Skip the first event from the ``view`` so when
            // wiring up, the ``model`` subject is the one
            // that defines the initial configuration.
            // TODO. This works when both try to fire
            // events on subscription ( BehaviorSubject )
            // but I'm not sure it works in other cases.
            // Needs testings
            var d1 = viewObserver
                .DistinctUntilChanged(EqualityComparer<T>.Default )
                .SkipUntil(enableView.Take(1))
                .ObserveOn(scheduler)
                .Subscribe(v =>
                    {
                        if (validateView(v))
                            modelSubject.OnNext(v);
                    }
                , onError: modelSubject.OnError
                ,onCompleted: modelSubject.OnCompleted
            );

            IObservable<T> modelObserver = modelSubject;
            modelObserver = updateViewOn !=null ? modelObserver.SampleOrAll(updateViewOn) : modelObserver;
            var d0 = modelObserver 
                .DistinctUntilChanged(EqualityComparer<T>.Default )
                .ObserveOn(scheduler)
                .Subscribe(v=>
            {
                    viewSubject.OnNext(v);
                    validateView(v);
                    enableView.OnNext(Unit.Default);
            },
            onError: viewSubject.OnError
            ,onCompleted: viewSubject.OnCompleted);

            return new CompositeDisposable(d0, d1);
        }

    }
}
