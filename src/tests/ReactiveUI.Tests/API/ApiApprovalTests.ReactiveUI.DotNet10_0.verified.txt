[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.AOT.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.AndroidX")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Avalonia")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Blazor")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Blend")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Builder.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Builder.WpfApp")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Drawing")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Maui")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.NonParallel.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Testing")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Uno")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Uno.WinUI")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.WinUI")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Winforms")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("ReactiveUI.Wpf")]
namespace ReactiveUI
{
    public static class AutoPersistHelper
    {
        public static System.IDisposable ActOnEveryObject<TItem>(this System.Collections.ObjectModel.ObservableCollection<TItem> @this, System.Action<TItem> onAdd, System.Action<TItem> onRemove)
            where TItem : ReactiveUI.IReactiveObject { }
        public static System.IDisposable ActOnEveryObject<TItem>(this System.Collections.ObjectModel.ReadOnlyObservableCollection<TItem> @this, System.Action<TItem> onAdd, System.Action<TItem> onRemove)
            where TItem : ReactiveUI.IReactiveObject { }
        public static System.IDisposable ActOnEveryObject<TItem>(this System.IObservable<DynamicData.IChangeSet<TItem>> @this, System.Action<TItem> onAdd, System.Action<TItem> onRemove)
            where TItem : ReactiveUI.IReactiveObject { }
        public static System.IDisposable ActOnEveryObject<TItem, TCollection>(this TCollection collection, System.Action<TItem> onAdd, System.Action<TItem> onRemove)
            where TItem : ReactiveUI.IReactiveObject
            where TCollection : System.Collections.Specialized.INotifyCollectionChanged, System.Collections.Generic.IEnumerable<TItem> { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("AutoPersist may reflect over the runtime type when it differs from T. In trimmed/" +
            "AOT builds, required property/attribute metadata may be removed unless explicitl" +
            "y preserved. Prefer the overloads that accept AutoPersistMetadata to avoid runti" +
            "me reflection.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("AutoPersist may reflect over the runtime type when it differs from T. In trimmed/" +
            "AOT builds, required property/attribute metadata may be removed unless explicitl" +
            "y preserved. Prefer the overloads that accept AutoPersistMetadata to avoid runti" +
            "me reflection.")]
        public static System.IDisposable AutoPersist<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  T>(this T @this, System.Func<T, System.IObservable<System.Reactive.Unit>> doPersist, System.TimeSpan? interval = default)
            where T : ReactiveUI.IReactiveObject { }
        public static System.IDisposable AutoPersist<T>(this T @this, System.Func<T, System.IObservable<System.Reactive.Unit>> doPersist, ReactiveUI.AutoPersistHelper.AutoPersistMetadata metadata, System.TimeSpan? interval = default)
            where T : ReactiveUI.IReactiveObject { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("AutoPersist may reflect over the runtime type when it differs from T. In trimmed/" +
            "AOT builds, required property/attribute metadata may be removed unless explicitl" +
            "y preserved. Prefer the overloads that accept AutoPersistMetadata to avoid runti" +
            "me reflection.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("AutoPersist may reflect over the runtime type when it differs from T. In trimmed/" +
            "AOT builds, required property/attribute metadata may be removed unless explicitl" +
            "y preserved. Prefer the overloads that accept AutoPersistMetadata to avoid runti" +
            "me reflection.")]
        public static System.IDisposable AutoPersist<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  T, TDontCare>(this T @this, System.Func<T, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, System.TimeSpan? interval = default)
            where T : ReactiveUI.IReactiveObject { }
        public static System.IDisposable AutoPersist<T, TDontCare>(this T @this, System.Func<T, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, ReactiveUI.AutoPersistHelper.AutoPersistMetadata metadata, System.TimeSpan? interval = default)
            where T : ReactiveUI.IReactiveObject { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode(@"AutoPersistCollection may reflect over runtime item types via AutoPersist when generic type parameters do not match item runtime types. In trimmed/AOT builds, required property/attribute metadata may be removed unless explicitly preserved. Prefer the overloads that accept AutoPersistMetadata or a metadata provider to avoid runtime reflection.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode(@"AutoPersistCollection may reflect over runtime item types via AutoPersist when generic type parameters do not match item runtime types. In trimmed/AOT builds, required property/attribute metadata may be removed unless explicitly preserved. Prefer the overloads that accept AutoPersistMetadata or a metadata provider to avoid runtime reflection.")]
        public static System.IDisposable AutoPersistCollection<TItem>(this System.Collections.ObjectModel.ObservableCollection<TItem> @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject { }
        public static System.IDisposable AutoPersistCollection<TItem>(this System.Collections.ObjectModel.ObservableCollection<TItem> @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, ReactiveUI.AutoPersistHelper.AutoPersistMetadata metadata, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode(@"AutoPersistCollection may reflect over runtime item types via AutoPersist when generic type parameters do not match item runtime types. In trimmed/AOT builds, required property/attribute metadata may be removed unless explicitly preserved. Prefer the overloads that accept AutoPersistMetadata or a metadata provider to avoid runtime reflection.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode(@"AutoPersistCollection may reflect over runtime item types via AutoPersist when generic type parameters do not match item runtime types. In trimmed/AOT builds, required property/attribute metadata may be removed unless explicitly preserved. Prefer the overloads that accept AutoPersistMetadata or a metadata provider to avoid runtime reflection.")]
        public static System.IDisposable AutoPersistCollection<TItem, TDontCare>(this System.Collections.ObjectModel.ObservableCollection<TItem> @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode(@"AutoPersistCollection may reflect over runtime item types via AutoPersist when generic type parameters do not match item runtime types. In trimmed/AOT builds, required property/attribute metadata may be removed unless explicitly preserved. Prefer the overloads that accept AutoPersistMetadata or a metadata provider to avoid runtime reflection.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode(@"AutoPersistCollection may reflect over runtime item types via AutoPersist when generic type parameters do not match item runtime types. In trimmed/AOT builds, required property/attribute metadata may be removed unless explicitly preserved. Prefer the overloads that accept AutoPersistMetadata or a metadata provider to avoid runtime reflection.")]
        public static System.IDisposable AutoPersistCollection<TItem, TDontCare>(this System.Collections.ObjectModel.ReadOnlyObservableCollection<TItem> @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject { }
        public static System.IDisposable AutoPersistCollection<TItem, TDontCare>(this System.Collections.ObjectModel.ObservableCollection<TItem> @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, ReactiveUI.AutoPersistHelper.AutoPersistMetadata metadata, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject { }
        public static System.IDisposable AutoPersistCollection<TItem, TDontCare>(this System.Collections.ObjectModel.ReadOnlyObservableCollection<TItem> @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, ReactiveUI.AutoPersistHelper.AutoPersistMetadata metadata, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode(@"AutoPersistCollection may reflect over runtime item types via AutoPersist when generic type parameters do not match item runtime types. In trimmed/AOT builds, required property/attribute metadata may be removed unless explicitly preserved. Prefer the overloads that accept AutoPersistMetadata or a metadata provider to avoid runtime reflection.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode(@"AutoPersistCollection may reflect over runtime item types via AutoPersist when generic type parameters do not match item runtime types. In trimmed/AOT builds, required property/attribute metadata may be removed unless explicitly preserved. Prefer the overloads that accept AutoPersistMetadata or a metadata provider to avoid runtime reflection.")]
        public static System.IDisposable AutoPersistCollection<TItem, TCollection, TDontCare>(this TCollection @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject
            where TCollection : System.Collections.Specialized.INotifyCollectionChanged, System.Collections.Generic.IEnumerable<TItem> { }
        public static System.IDisposable AutoPersistCollection<TItem, TCollection, TDontCare>(this TCollection @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, ReactiveUI.AutoPersistHelper.AutoPersistMetadata metadata, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject
            where TCollection : System.Collections.Specialized.INotifyCollectionChanged, System.Collections.Generic.IEnumerable<TItem> { }
        public static System.IDisposable AutoPersistCollection<TItem, TCollection, TDontCare>(this TCollection @this, System.Func<TItem, System.IObservable<System.Reactive.Unit>> doPersist, System.IObservable<TDontCare> manualSaveSignal, System.Func<TItem, ReactiveUI.AutoPersistHelper.AutoPersistMetadata> metadataProvider, System.TimeSpan? interval = default)
            where TItem : ReactiveUI.IReactiveObject
            where TCollection : System.Collections.Specialized.INotifyCollectionChanged, System.Collections.Generic.IEnumerable<TItem> { }
        public static ReactiveUI.AutoPersistHelper.AutoPersistMetadata CreateMetadata<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  T>()
            where T : ReactiveUI.IReactiveObject { }
        public static System.Func<TItem, ReactiveUI.AutoPersistHelper.AutoPersistMetadata> CreateMetadataProvider<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TItem>()
            where TItem : ReactiveUI.IReactiveObject { }
        public sealed class AutoPersistMetadata
        {
            public AutoPersistMetadata(bool hasDataContract, System.Collections.Generic.ISet<string> persistablePropertyNames) { }
            public bool HasDataContract { get; }
            public System.Collections.Generic.ISet<string> PersistablePropertyNames { get; }
        }
    }
    public enum BindingDirection
    {
        OneWay = 0,
        TwoWay = 1,
        AsyncOneWay = 2,
    }
    public abstract class BindingTypeConverter<TFrom, TTo> : ReactiveUI.IBindingTypeConverter, ReactiveUI.IBindingTypeConverter<TFrom, TTo>, Splat.IEnableLogger
    {
        protected BindingTypeConverter() { }
        public System.Type FromType { get; }
        public System.Type ToType { get; }
        public virtual int GetAffinityForObjects() { }
        public abstract bool TryConvert(TFrom? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TTo? result);
        public bool TryConvertTyped(object? from, object? conversionHint, out object? result) { }
    }
    public sealed class BooleanToStringTypeConverter : ReactiveUI.BindingTypeConverter<bool, string>
    {
        public BooleanToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(bool from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class ByteToStringTypeConverter : ReactiveUI.BindingTypeConverter<byte, string>
    {
        public ByteToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(byte from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public class CanActivateViewFetcher : ReactiveUI.IActivationForViewFetcher
    {
        public CanActivateViewFetcher() { }
        public System.IObservable<bool> GetActivationForView(ReactiveUI.IActivatableView view) { }
        public int GetAffinityForView(System.Type view) { }
    }
    public static class ChangeSetMixin
    {
        public static System.IObservable<DynamicData.IChangeSet> CountChanged(this System.IObservable<DynamicData.IChangeSet> changeSet) { }
        public static System.IObservable<DynamicData.IChangeSet<T>> CountChanged<T>(this System.IObservable<DynamicData.IChangeSet<T>> changeSet)
            where T :  notnull { }
        public static bool HasCountChanged(this DynamicData.IChangeSet changeSet) { }
    }
    public class CombinedReactiveCommand<TParam, TResult> : ReactiveUI.ReactiveCommandBase<TParam, System.Collections.Generic.IList<TResult>>
    {
        protected CombinedReactiveCommand(System.Collections.Generic.IEnumerable<ReactiveUI.ReactiveCommandBase<TParam, TResult>> childCommands, System.IObservable<bool>? canExecute, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public override System.IObservable<bool> CanExecute { get; }
        public override System.IObservable<bool> IsExecuting { get; }
        public override System.IObservable<System.Exception> ThrownExceptions { get; }
        protected override void Dispose(bool disposing) { }
        public override System.IObservable<System.Collections.Generic.IList<TResult>> Execute() { }
        public override System.IObservable<System.Collections.Generic.IList<TResult>> Execute(TParam parameter) { }
        public override System.IDisposable Subscribe(System.IObserver<System.Collections.Generic.IList<TResult>> observer) { }
    }
    public static class CommandBinder
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public static ReactiveUI.IReactiveBinding<TView, TProp> BindCommand<TView, TViewModel, TProp, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  TControl>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TProp?>> propertyName, System.Linq.Expressions.Expression<System.Func<TView, TControl>> controlName, string? toEvent = null)
            where TView :  class, ReactiveUI.IViewFor
            where TViewModel :  class
            where TProp : System.Windows.Input.ICommand
            where TControl :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public static ReactiveUI.IReactiveBinding<TView, TProp> BindCommand<TView, TViewModel, TProp, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  TControl, TParam>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TProp?>> propertyName, System.Linq.Expressions.Expression<System.Func<TView, TControl>> controlName, System.IObservable<TParam?> withParameter, string? toEvent = null)
            where TView :  class, ReactiveUI.IViewFor
            where TViewModel :  class
            where TProp : System.Windows.Input.ICommand
            where TControl :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public static ReactiveUI.IReactiveBinding<TView, TProp> BindCommand<TView, TViewModel, TProp, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  TControl, TParam>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TProp?>> propertyName, System.Linq.Expressions.Expression<System.Func<TView, TControl>> controlName, System.Linq.Expressions.Expression<System.Func<TViewModel, TParam?>> withParameter, string? toEvent = null)
            where TView :  class, ReactiveUI.IViewFor
            where TViewModel :  class
            where TProp : System.Windows.Input.ICommand
            where TControl :  class { }
    }
    public class CommandBinderImplementation : Splat.IEnableLogger
    {
        public CommandBinderImplementation() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public ReactiveUI.IReactiveBinding<TView, TProp> BindCommand<TView, TViewModel, TProp, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  TControl, TParam>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TControl>> controlProperty, System.IObservable<TParam?> withParameter, string? toEvent = null)
            where TView :  class, ReactiveUI.IViewFor
            where TViewModel :  class
            where TProp : System.Windows.Input.ICommand
            where TControl :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public ReactiveUI.IReactiveBinding<TView, TProp> BindCommand<TView, TViewModel, TProp, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  TControl, TParam>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TControl>> controlProperty, System.Linq.Expressions.Expression<System.Func<TViewModel, TParam?>> withParameter, string? toEvent = null)
            where TView :  class, ReactiveUI.IViewFor
            where TViewModel :  class
            where TProp : System.Windows.Input.ICommand
            where TControl :  class { }
    }
    public static class ComparerChainingExtensions
    {
        public static System.Collections.Generic.IComparer<T> ThenBy<T, TValue>(this System.Collections.Generic.IComparer<T>? parent, System.Func<T, TValue> selector) { }
        public static System.Collections.Generic.IComparer<T> ThenBy<T, TValue>(this System.Collections.Generic.IComparer<T>? parent, System.Func<T, TValue> selector, System.Collections.Generic.IComparer<TValue> comparer) { }
        public static System.Collections.Generic.IComparer<T> ThenByDescending<T, TValue>(this System.Collections.Generic.IComparer<T>? parent, System.Func<T, TValue> selector) { }
        public static System.Collections.Generic.IComparer<T> ThenByDescending<T, TValue>(this System.Collections.Generic.IComparer<T>? parent, System.Func<T, TValue> selector, System.Collections.Generic.IComparer<TValue> comparer) { }
    }
    public sealed class ComponentModelFallbackConverter : ReactiveUI.IBindingFallbackConverter, Splat.IEnableLogger
    {
        public ComponentModelFallbackConverter() { }
        [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification="The callers of this method ensure getting the converter is trim compatible - i.e." +
            " the type is not Nullable<T>.")]
        public int GetAffinityForObjects([System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type fromType, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type toType) { }
        public bool TryConvert([System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type fromType, object from, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type toType, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out object? result) { }
    }
    public sealed class CreatesCommandBindingViaCommandParameter : ReactiveUI.ICreatesCommandBinding
    {
        public CreatesCommandBindingViaCommandParameter() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("String/reflection-based event binding may require members removed by trimming.")]
        public System.IDisposable? BindCommandToObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  T>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter)
            where T :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("String/reflection-based event binding may require members removed by trimming.")]
        public System.IDisposable? BindCommandToObject<T, TEventArgs>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter, string eventName)
            where T :  class { }
        public System.IDisposable? BindCommandToObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  T, TEventArgs>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter, System.Action<System.EventHandler<TEventArgs>> addHandler, System.Action<System.EventHandler<TEventArgs>> removeHandler)
            where T :  class
            where TEventArgs : System.EventArgs { }
        public int GetAffinityForObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents)]  T>(bool hasEventTarget) { }
    }
    public sealed class CreatesCommandBindingViaEvent : ReactiveUI.ICreatesCommandBinding
    {
        public CreatesCommandBindingViaEvent() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("String/reflection-based event binding may require members removed by trimming.")]
        public System.IDisposable? BindCommandToObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  T>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter)
            where T :  class { }
        public System.IDisposable BindCommandToObject<T>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter, System.Action<System.EventHandler> addHandler, System.Action<System.EventHandler> removeHandler)
            where T :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("String/reflection-based event binding may require members removed by trimming.")]
        public System.IDisposable? BindCommandToObject<T, TEventArgs>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter, string eventName)
            where T :  class { }
        public System.IDisposable? BindCommandToObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  T, TEventArgs>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter, System.Action<System.EventHandler<TEventArgs>> addHandler, System.Action<System.EventHandler<TEventArgs>> removeHandler)
            where T :  class
            where TEventArgs : System.EventArgs { }
        public int GetAffinityForObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents)]  T>(bool hasEventTarget) { }
    }
    public sealed class DateOnlyToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.DateOnly, string>
    {
        public DateOnlyToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.DateOnly from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class DateTimeOffsetToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.DateTimeOffset, string>
    {
        public DateTimeOffsetToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.DateTimeOffset from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class DateTimeToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.DateTime, string>
    {
        public DateTimeToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.DateTime from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class DecimalToStringTypeConverter : ReactiveUI.BindingTypeConverter<decimal, string>
    {
        public DecimalToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(decimal from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class DefaultViewLocator : ReactiveUI.IViewLocator, Splat.IEnableLogger
    {
        public ReactiveUI.DefaultViewLocator Map<TViewModel, TView>(System.Func<TView> factory, string? contract = null)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor<TViewModel> { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("If some of the generic arguments are annotated (either with DynamicallyAccessedMe" +
            "mbersAttribute, or generic constraints), trimming can\'t validate that the requir" +
            "ements of those annotations are met.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("This method uses reflection to determine the view model type at runtime, which ma" +
            "y be incompatible with trimming.")]
        public ReactiveUI.IViewFor<object>? ResolveView(object? instance, string? contract = null) { }
        public ReactiveUI.IViewFor<TViewModel>? ResolveView<TViewModel>(string? contract = null)
            where TViewModel :  class { }
        public ReactiveUI.DefaultViewLocator Unmap<TViewModel>(string? contract = null)
            where TViewModel :  class { }
    }
    public static class DependencyResolverMixins
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Scans assembly for IViewFor implementations using reflection. For AOT compatibili" +
            "ty, use the ReactiveUIBuilder pattern to register views explicitly.")]
        public static void RegisterViewsForViewModels(this Splat.IMutableDependencyResolver resolver, System.Reflection.Assembly assembly) { }
    }
    public sealed class DoubleToStringTypeConverter : ReactiveUI.BindingTypeConverter<double, string>
    {
        public DoubleToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(double from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class DummySuspensionDriver : ReactiveUI.ISuspensionDriver
    {
        public DummySuspensionDriver() { }
        public System.IObservable<System.Reactive.Unit> InvalidateState() { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("Implementations commonly use reflection-based serialization. Prefer LoadState<T>(" +
            "JsonTypeInfo<T>) for trimming or AOT scenarios.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Implementations commonly use reflection-based serialization. Prefer LoadState<T>(" +
            "JsonTypeInfo<T>) for trimming or AOT scenarios.")]
        public System.IObservable<object?> LoadState() { }
        public System.IObservable<T?> LoadState<T>(System.Text.Json.Serialization.Metadata.JsonTypeInfo<T> typeInfo) { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("Implementations commonly use reflection-based serialization. Prefer SaveState<T>(" +
            "T, JsonTypeInfo<T>) for trimming or AOT scenarios.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Implementations commonly use reflection-based serialization. Prefer SaveState<T>(" +
            "T, JsonTypeInfo<T>) for trimming or AOT scenarios.")]
        public System.IObservable<System.Reactive.Unit> SaveState<T>(T state) { }
        public System.IObservable<System.Reactive.Unit> SaveState<T>(T state, System.Text.Json.Serialization.Metadata.JsonTypeInfo<T> typeInfo) { }
    }
    public sealed class EqualityTypeConverter : ReactiveUI.IBindingTypeConverter, Splat.IEnableLogger
    {
        public EqualityTypeConverter() { }
        public System.Type FromType { get; }
        public System.Type ToType { get; }
        public int GetAffinityForObjects() { }
        public bool TryConvertTyped(object? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out object? result) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
    public sealed class ExcludeFromViewRegistrationAttribute : System.Attribute
    {
        public ExcludeFromViewRegistrationAttribute() { }
    }
    public static class ExpressionMixins
    {
        public static object?[]? GetArgumentsArray(this System.Linq.Expressions.Expression expression) { }
        public static System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression> GetExpressionChain(this System.Linq.Expressions.Expression expression) { }
        public static System.Reflection.MemberInfo? GetMemberInfo(this System.Linq.Expressions.Expression expression) { }
        public static System.Linq.Expressions.Expression? GetParent(this System.Linq.Expressions.Expression expression) { }
    }
    public sealed class GuidToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.Guid, string>
    {
        public GuidToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.Guid from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public interface IActivatableView { }
    public interface IActivatableViewModel
    {
        ReactiveUI.ViewModelActivator Activator { get; }
    }
    public interface IActivationForViewFetcher
    {
        System.IObservable<bool> GetActivationForView(ReactiveUI.IActivatableView view);
        int GetAffinityForView(System.Type view);
    }
    public interface IBindingFallbackConverter : Splat.IEnableLogger
    {
        int GetAffinityForObjects([System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type fromType, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type toType);
        bool TryConvert([System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type fromType, object from, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type toType, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out object? result);
    }
    public interface IBindingTypeConverter : Splat.IEnableLogger
    {
        System.Type FromType { get; }
        System.Type ToType { get; }
        int GetAffinityForObjects();
        bool TryConvertTyped(object? from, object? conversionHint, out object? result);
    }
    public interface IBindingTypeConverter<TFrom, TTo> : ReactiveUI.IBindingTypeConverter, Splat.IEnableLogger
    {
        bool TryConvert(TFrom? from, object? conversionHint, out TTo? result);
    }
    public interface ICanActivate
    {
        System.IObservable<System.Reactive.Unit> Activated { get; }
        System.IObservable<System.Reactive.Unit> Deactivated { get; }
    }
    public interface IComparerBuilder<T>
    {
        System.Collections.Generic.IComparer<T> OrderBy<TValue>(System.Func<T, TValue> selector);
        System.Collections.Generic.IComparer<T> OrderBy<TValue>(System.Func<T, TValue> selector, System.Collections.Generic.IComparer<TValue> comparer);
        System.Collections.Generic.IComparer<T> OrderByDescending<TValue>(System.Func<T, TValue> selector);
        System.Collections.Generic.IComparer<T> OrderByDescending<TValue>(System.Func<T, TValue> selector, System.Collections.Generic.IComparer<TValue> comparer);
    }
    public interface ICreatesCommandBinding
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("String/reflection-based event binding may require members removed by trimming.")]
        System.IDisposable? BindCommandToObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  T>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter)
            where T :  class;
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("String/reflection-based event binding may require members removed by trimming.")]
        System.IDisposable? BindCommandToObject<T, TEventArgs>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter, string eventName)
            where T :  class;
        System.IDisposable? BindCommandToObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents)]  T, TEventArgs>(System.Windows.Input.ICommand? command, T? target, System.IObservable<object?> commandParameter, System.Action<System.EventHandler<TEventArgs>> addHandler, System.Action<System.EventHandler<TEventArgs>> removeHandler)
            where T :  class
            where TEventArgs : System.EventArgs;
        int GetAffinityForObject<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents)]  T>(bool hasEventTarget);
    }
    public interface ICreatesObservableForProperty : Splat.IEnableLogger
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types which is not trim- or AOT-safe.")]
        int GetAffinityForObject(System.Type type, string propertyName, bool beforeChanged = false);
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types which is not trim- or AOT-safe.")]
        System.IObservable<ReactiveUI.IObservedChange<object?, object?>> GetNotificationForProperty(object sender, System.Linq.Expressions.Expression expression, string propertyName, bool beforeChanged = false, bool suppressWarnings = false);
    }
    public interface IHandleObservableErrors
    {
        System.IObservable<System.Exception> ThrownExceptions { get; }
    }
    public interface IInteractionBinderImplementation : Splat.IEnableLogger
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        System.IDisposable BindInteraction<TViewModel, TView, TInput, TOutput>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, ReactiveUI.IInteraction<TInput, TOutput>>> propertyName, System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.Threading.Tasks.Task> handler)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor;
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        System.IDisposable BindInteraction<TViewModel, TView, TInput, TOutput, TDontCare>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, ReactiveUI.IInteraction<TInput, TOutput>>> propertyName, System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.IObservable<TDontCare>> handler)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor;
    }
    public interface IInteractionContext<out TInput, in TOutput>
    {
        TInput Input { get; }
        bool IsHandled { get; }
        void SetOutput(TOutput output);
    }
    public interface IInteraction<TInput, TOutput>
    {
        System.IObservable<TOutput> Handle(TInput input);
        System.IDisposable RegisterHandler(System.Action<ReactiveUI.IInteractionContext<TInput, TOutput>> handler);
        System.IDisposable RegisterHandler(System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.Threading.Tasks.Task> handler);
        System.IDisposable RegisterHandler<TDontCare>(System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.IObservable<TDontCare>> handler);
    }
    public interface IMessageBus : Splat.IEnableLogger
    {
        bool IsRegistered(System.Type type, string? contract = null);
        System.IObservable<T> Listen<T>(string? contract = null);
        System.IObservable<T> ListenIncludeLatest<T>(string? contract = null);
        System.IDisposable RegisterMessageSource<T>(System.IObservable<T> source, string? contract = null);
        void RegisterScheduler<T>(System.Reactive.Concurrency.IScheduler scheduler, string? contract = null);
        void SendMessage<T>(T message, string? contract = null);
    }
    public class INPCObservableForProperty : ReactiveUI.ICreatesObservableForProperty, Splat.IEnableLogger
    {
        public INPCObservableForProperty() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types which is not trim- or AOT-safe.")]
        public int GetAffinityForObject(System.Type type, string propertyName, bool beforeChanged) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types which is not trim- or AOT-safe.")]
        public System.IObservable<ReactiveUI.IObservedChange<object?, object?>> GetNotificationForProperty(object sender, System.Linq.Expressions.Expression expression, string propertyName, bool beforeChanged = false, bool suppressWarnings = false) { }
    }
    public interface IObservedChange<out TSender, out TValue>
    {
        System.Linq.Expressions.Expression? Expression { get; }
        TSender Sender { get; }
        TValue Value { get; }
    }
    public interface IOutputContext<out TInput, TOutput> : ReactiveUI.IInteractionContext<TInput, TOutput>
    {
        TOutput GetOutput();
    }
    public interface IPlatformOperations
    {
        string? GetOrientation();
    }
    public interface IPropertyBinderImplementation : Splat.IEnableLogger
    {
        [return: System.Runtime.CompilerServices.TupleElementNames(new string[] {
                "view",
                "isViewModel"})]
        ReactiveUI.IReactiveBinding<TView, System.ValueTuple<object?, bool>> Bind<TViewModel, TView, TVMProp, TVProp, TDontCare>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, System.IObservable<TDontCare>? signalViewUpdate, System.Func<TVMProp?, TVProp> vmToViewConverter, System.Func<TVProp, TVMProp?> viewToVmConverter, ReactiveUI.TriggerUpdate triggerUpdate = 0)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor;
        [return: System.Runtime.CompilerServices.TupleElementNames(new string?[]?[] {
                "view",
                "isViewModel"})]
        ReactiveUI.IReactiveBinding<TView, System.ValueTuple<object?, bool>> Bind<TViewModel, TView, TVMProp, TVProp, TDontCare>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, System.IObservable<TDontCare>? signalViewUpdate, object? conversionHint, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null, ReactiveUI.IBindingTypeConverter? viewToVMConverterOverride = null, ReactiveUI.TriggerUpdate triggerUpdate = 0)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor;
        System.IDisposable BindTo<TValue, TTarget, TTValue>(System.IObservable<TValue> observedChange, TTarget? target, System.Linq.Expressions.Expression<System.Func<TTarget, TTValue?>> propertyExpression, object? conversionHint, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null)
            where TTarget :  class;
        ReactiveUI.IReactiveBinding<TView, TOut> OneWayBind<TViewModel, TView, TProp, TOut>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TProp>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TOut>> viewProperty, System.Func<TProp, TOut> selector)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor;
        ReactiveUI.IReactiveBinding<TView, TVProp> OneWayBind<TViewModel, TView, TVMProp, TVProp>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, object? conversionHint, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor;
    }
    public interface IPropertyBindingHook
    {
        bool ExecuteHook(object? source, object target, System.Func<ReactiveUI.IObservedChange<object, object>[]> getCurrentViewModelProperties, System.Func<ReactiveUI.IObservedChange<object, object>[]> getCurrentViewProperties, ReactiveUI.BindingDirection direction);
    }
    public sealed class IROObservableForProperty : ReactiveUI.ICreatesObservableForProperty, Splat.IEnableLogger
    {
        public IROObservableForProperty() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types which is not trim- or AOT-safe.")]
        public int GetAffinityForObject(System.Type type, string propertyName, bool beforeChanged = false) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types which is not trim- or AOT-safe.")]
        public System.IObservable<ReactiveUI.IObservedChange<object, object?>> GetNotificationForProperty(object sender, System.Linq.Expressions.Expression expression, string propertyName, bool beforeChanged = false, bool suppressWarnings = false) { }
    }
    public interface IReactiveBinding<out TView, out TValue> : System.IDisposable
        where out TView : ReactiveUI.IViewFor
    {
        System.IObservable<TValue?> Changed { get; }
        ReactiveUI.BindingDirection Direction { get; }
        TView View { get; }
        System.Linq.Expressions.Expression ViewExpression { get; }
        System.Linq.Expressions.Expression ViewModelExpression { get; }
    }
    public interface IReactiveCommand : ReactiveUI.IHandleObservableErrors, System.IDisposable
    {
        System.IObservable<bool> CanExecute { get; }
        System.IObservable<bool> IsExecuting { get; }
    }
    public interface IReactiveCommand<in TParam, out TResult> : ReactiveUI.IHandleObservableErrors, ReactiveUI.IReactiveCommand, System.IDisposable, System.IObservable<TResult>
    {
        System.IObservable<TResult> Execute();
        System.IObservable<TResult> Execute(TParam parameter);
    }
    public interface IReactiveNotifyPropertyChanged<out TSender>
    {
        System.IObservable<ReactiveUI.IReactivePropertyChangedEventArgs<TSender>> Changed { get; }
        System.IObservable<ReactiveUI.IReactivePropertyChangedEventArgs<TSender>> Changing { get; }
        System.IDisposable SuppressChangeNotifications();
    }
    public interface IReactiveObject : Splat.IEnableLogger, System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.INotifyPropertyChanging
    {
        void RaisePropertyChanged(System.ComponentModel.PropertyChangedEventArgs args);
        void RaisePropertyChanging(System.ComponentModel.PropertyChangingEventArgs args);
    }
    public static class IReactiveObjectExtensions
    {
        public static TRet RaiseAndSetIfChanged<TObj, TRet>(this TObj reactiveObject, ref TRet backingField, TRet newValue, [System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
            where TObj : ReactiveUI.IReactiveObject { }
        public static void RaisePropertyChanged<TSender>(this TSender reactiveObject, [System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
            where TSender : ReactiveUI.IReactiveObject { }
        public static void RaisePropertyChanging<TSender>(this TSender reactiveObject, [System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
            where TSender : ReactiveUI.IReactiveObject { }
        public static void SubscribePropertyChangedEvents<TSender>(this TSender reactiveObject)
            where TSender : ReactiveUI.IReactiveObject { }
        public static void SubscribePropertyChangingEvents<TSender>(this TSender reactiveObject)
            where TSender : ReactiveUI.IReactiveObject { }
    }
    public interface IReactivePropertyChangedEventArgs<out TSender>
    {
        string? PropertyName { get; }
        TSender Sender { get; }
    }
    public interface IReactiveProperty<T> : System.ComponentModel.INotifyDataErrorInfo, System.ComponentModel.INotifyPropertyChanged, System.IDisposable, System.IObservable<T?>, System.Reactive.Disposables.ICancelable
    {
        System.IObservable<System.Collections.IEnumerable?> ObserveErrorChanged { get; }
        System.IObservable<bool> ObserveHasErrors { get; }
        T Value { get; set; }
        void Refresh();
    }
    public interface IRegistrar
    {
        void Register<TService>(System.Func<TService> factory, string? contract = null)
            where TService :  class;
        void RegisterConstant<TService>(System.Func<TService> factory, string? contract = null)
            where TService :  class;
        void RegisterLazySingleton<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)]  TService>(System.Func<TService> factory, string? contract = null)
            where TService :  class;
    }
    public interface IRoutableViewModel : ReactiveUI.IReactiveObject, Splat.IEnableLogger, System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.INotifyPropertyChanging
    {
        ReactiveUI.IScreen HostScreen { get; }
        string? UrlPathSegment { get; }
    }
    public interface IScreen
    {
        ReactiveUI.RoutingState Router { get; }
    }
    public interface ISetMethodBindingConverter : Splat.IEnableLogger
    {
        int GetAffinityForObjects(System.Type? fromType, System.Type? toType);
        object? PerformSet(object? toTarget, object? newValue, object?[]? arguments);
    }
    public interface ISuspensionDriver
    {
        System.IObservable<System.Reactive.Unit> InvalidateState();
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("Implementations commonly use reflection-based serialization. Prefer LoadState<T>(" +
            "JsonTypeInfo<T>) for trimming or AOT scenarios.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Implementations commonly use reflection-based serialization. Prefer LoadState<T>(" +
            "JsonTypeInfo<T>) for trimming or AOT scenarios.")]
        System.IObservable<object?> LoadState();
        System.IObservable<T?> LoadState<T>(System.Text.Json.Serialization.Metadata.JsonTypeInfo<T> typeInfo);
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("Implementations commonly use reflection-based serialization. Prefer SaveState<T>(" +
            "T, JsonTypeInfo<T>) for trimming or AOT scenarios.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Implementations commonly use reflection-based serialization. Prefer SaveState<T>(" +
            "T, JsonTypeInfo<T>) for trimming or AOT scenarios.")]
        System.IObservable<System.Reactive.Unit> SaveState<T>(T state);
        System.IObservable<System.Reactive.Unit> SaveState<T>(T state, System.Text.Json.Serialization.Metadata.JsonTypeInfo<T> typeInfo);
    }
    public interface ISuspensionHost : ReactiveUI.IReactiveObject, Splat.IEnableLogger, System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.INotifyPropertyChanging
    {
        object? AppState { get; set; }
        System.Func<object>? CreateNewAppState { get; set; }
        System.IObservable<System.Reactive.Unit> IsLaunchingNew { get; set; }
        System.IObservable<System.Reactive.Unit> IsResuming { get; set; }
        System.IObservable<System.Reactive.Unit> IsUnpausing { get; set; }
        System.IObservable<System.Reactive.Unit> ShouldInvalidateState { get; set; }
        System.IObservable<System.IDisposable> ShouldPersistState { get; set; }
    }
    public interface IViewFor : ReactiveUI.IActivatableView
    {
        object? ViewModel { get; set; }
    }
    public interface IViewFor<T> : ReactiveUI.IActivatableView, ReactiveUI.IViewFor
        where T :  class
    {
        T ViewModel { get; set; }
    }
    public interface IViewLocator : Splat.IEnableLogger
    {
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("If some of the generic arguments are annotated (either with DynamicallyAccessedMe" +
            "mbersAttribute, or generic constraints), trimming can\'t validate that the requir" +
            "ements of those annotations are met.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("This method uses reflection to determine the view model type at runtime, which ma" +
            "y be incompatible with trimming.")]
        ReactiveUI.IViewFor<object>? ResolveView(object? instance, string? contract = null);
        ReactiveUI.IViewFor<TViewModel>? ResolveView<TViewModel>(string? contract = null)
            where TViewModel :  class;
    }
    public interface IViewModule
    {
        void RegisterViews(ReactiveUI.DefaultViewLocator locator);
    }
    public interface IWantsToRegisterStuff
    {
        void Register(ReactiveUI.IRegistrar registrar);
    }
    public sealed class IntegerToStringTypeConverter : ReactiveUI.BindingTypeConverter<int, string>
    {
        public IntegerToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(int from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public class InteractionBinderImplementation : ReactiveUI.IInteractionBinderImplementation, Splat.IEnableLogger
    {
        public InteractionBinderImplementation() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public System.IDisposable BindInteraction<TViewModel, TView, TInput, TOutput>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, ReactiveUI.IInteraction<TInput, TOutput>>> propertyName, System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.Threading.Tasks.Task> handler)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public System.IDisposable BindInteraction<TViewModel, TView, TInput, TOutput, TDontCare>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, ReactiveUI.IInteraction<TInput, TOutput>>> propertyName, System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.IObservable<TDontCare>> handler)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
    }
    public static class InteractionBindingMixins
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public static System.IDisposable BindInteraction<TViewModel, TView, TInput, TOutput>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, ReactiveUI.IInteraction<TInput, TOutput>>> propertyName, System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.Threading.Tasks.Task> handler)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public static System.IDisposable BindInteraction<TViewModel, TView, TInput, TOutput, TDontCare>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, ReactiveUI.IInteraction<TInput, TOutput>>> propertyName, System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.IObservable<TDontCare>> handler)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
    }
    public sealed class InteractionContext<TInput, TOutput> : ReactiveUI.IInteractionContext<TInput, TOutput>, ReactiveUI.IOutputContext<TInput, TOutput>
    {
        public TInput Input { get; }
        public bool IsHandled { get; }
        public TOutput GetOutput() { }
        public void SetOutput(TOutput output) { }
    }
    public class Interaction<TInput, TOutput> : ReactiveUI.IInteraction<TInput, TOutput>
    {
        public Interaction(System.Reactive.Concurrency.IScheduler? handlerScheduler = null) { }
        protected virtual ReactiveUI.IOutputContext<TInput, TOutput> GenerateContext(TInput input) { }
        protected System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.IObservable<System.Reactive.Unit>>[] GetHandlers() { }
        public virtual System.IObservable<TOutput> Handle(TInput input) { }
        public System.IDisposable RegisterHandler(System.Action<ReactiveUI.IInteractionContext<TInput, TOutput>> handler) { }
        public System.IDisposable RegisterHandler(System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.Threading.Tasks.Task> handler) { }
        public System.IDisposable RegisterHandler<TDontCare>(System.Func<ReactiveUI.IInteractionContext<TInput, TOutput>, System.IObservable<TDontCare>> handler) { }
    }
    public sealed class LongToStringTypeConverter : ReactiveUI.BindingTypeConverter<long, string>
    {
        public LongToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(long from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public class MessageBus : ReactiveUI.IMessageBus, Splat.IEnableLogger
    {
        public MessageBus() { }
        public static ReactiveUI.IMessageBus Current { get; set; }
        public bool IsRegistered(System.Type type, string? contract = null) { }
        public System.IObservable<T> Listen<T>(string? contract = null) { }
        public System.IObservable<T> ListenIncludeLatest<T>(string? contract = null) { }
        public System.IDisposable RegisterMessageSource<T>(System.IObservable<T> source, string? contract = null) { }
        public void RegisterScheduler<T>(System.Reactive.Concurrency.IScheduler scheduler, string? contract = null) { }
        public void SendMessage<T>(T message, string? contract = null) { }
    }
    public static class MutableDependencyResolverExtensions
    {
        public static Splat.IMutableDependencyResolver RegisterSingletonViewForViewModel<TView, TViewModel>(this Splat.IMutableDependencyResolver resolver, string? contract = null)
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new ()
            where TViewModel :  class { }
        public static Splat.IMutableDependencyResolver RegisterViewForViewModel<TView, TViewModel>(this Splat.IMutableDependencyResolver resolver, string? contract = null)
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new ()
            where TViewModel :  class { }
    }
    public sealed class NullableBooleanToStringTypeConverter : ReactiveUI.BindingTypeConverter<bool?, string>
    {
        public NullableBooleanToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(bool? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableByteToStringTypeConverter : ReactiveUI.BindingTypeConverter<byte?, string>
    {
        public NullableByteToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(byte? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableDateOnlyToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.DateOnly?, string>
    {
        public NullableDateOnlyToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.DateOnly? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableDateTimeOffsetToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.DateTimeOffset?, string>
    {
        public NullableDateTimeOffsetToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.DateTimeOffset? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableDateTimeToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.DateTime?, string>
    {
        public NullableDateTimeToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.DateTime? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableDecimalToStringTypeConverter : ReactiveUI.BindingTypeConverter<decimal?, string>
    {
        public NullableDecimalToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(decimal? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableDoubleToStringTypeConverter : ReactiveUI.BindingTypeConverter<double?, string>
    {
        public NullableDoubleToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(double? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableGuidToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.Guid?, string>
    {
        public NullableGuidToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.Guid? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableIntegerToStringTypeConverter : ReactiveUI.BindingTypeConverter<int?, string>
    {
        public NullableIntegerToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(int? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableLongToStringTypeConverter : ReactiveUI.BindingTypeConverter<long?, string>
    {
        public NullableLongToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(long? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableShortToStringTypeConverter : ReactiveUI.BindingTypeConverter<short?, string>
    {
        public NullableShortToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(short? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableSingleToStringTypeConverter : ReactiveUI.BindingTypeConverter<float?, string>
    {
        public NullableSingleToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(float? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableTimeOnlyToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.TimeOnly?, string>
    {
        public NullableTimeOnlyToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.TimeOnly? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class NullableTimeSpanToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.TimeSpan?, string>
    {
        public NullableTimeSpanToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.TimeSpan? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public static class OAPHCreationHelperMixin
    {
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, System.Linq.Expressions.Expression<System.Func<TObj, TRet>> property, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, string property, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, System.Linq.Expressions.Expression<System.Func<TObj, TRet>> property, out ReactiveUI.ObservableAsPropertyHelper<TRet> result, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, System.Linq.Expressions.Expression<System.Func<TObj, TRet>> property, System.Func<TRet> getInitialValue, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, System.Linq.Expressions.Expression<System.Func<TObj, TRet>> property, TRet initialValue, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, string property, out ReactiveUI.ObservableAsPropertyHelper<TRet> result, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, string property, System.Func<TRet> getInitialValue, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, string property, TRet initialValue, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, System.Linq.Expressions.Expression<System.Func<TObj, TRet>> property, out ReactiveUI.ObservableAsPropertyHelper<TRet> result, System.Func<TRet> getInitialValue, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, System.Linq.Expressions.Expression<System.Func<TObj, TRet>> property, out ReactiveUI.ObservableAsPropertyHelper<TRet> result, TRet initialValue, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.ObservableAsPropertyHelper<TRet> ToProperty<TObj, TRet>(this System.IObservable<TRet> target, TObj source, string property, out ReactiveUI.ObservableAsPropertyHelper<TRet> result, System.Func<TRet> getInitialValue, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null)
            where TObj :  class, ReactiveUI.IReactiveObject { }
    }
    public sealed class ObservableAsPropertyHelper<T> : ReactiveUI.IHandleObservableErrors, Splat.IEnableLogger, System.IDisposable
    {
        public ObservableAsPropertyHelper(System.IObservable<T?> observable, System.Action<T?> onChanged, T? initialValue = default, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null) { }
        public ObservableAsPropertyHelper(System.IObservable<T?> observable, System.Action<T?> onChanged, System.Action<T?>? onChanging = null, System.Func<T?>? getInitialValue = null, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null) { }
        public ObservableAsPropertyHelper(System.IObservable<T?> observable, System.Action<T?> onChanged, System.Action<T?>? onChanging = null, T? initialValue = default, bool deferSubscription = false, System.Reactive.Concurrency.IScheduler? scheduler = null) { }
        public bool IsSubscribed { get; }
        public System.IObservable<System.Exception> ThrownExceptions { get; }
        public T Value { get; }
        public void Dispose() { }
        public static ReactiveUI.ObservableAsPropertyHelper<T> Default(T? initialValue = default, System.Reactive.Concurrency.IScheduler? scheduler = null) { }
    }
    public static class ObservableFuncMixins
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Dynamic observation uses reflection over members that may be trimmed.")]
        public static System.IObservable<TResult?> ToObservable<TSource, TResult>(this System.Linq.Expressions.Expression<System.Func<TSource, TResult?>> expression, TSource? source, bool beforeChange = false, bool skipInitial = false) { }
    }
    public static class ObservableLoggingMixin
    {
        public static System.IObservable<T> Log<T, TObj>(this System.IObservable<T> @this, TObj logObject, string? message = null, System.Func<T, string>? stringifier = null)
            where TObj : Splat.IEnableLogger { }
        public static System.IObservable<T> LoggedCatch<T, TObj>(this System.IObservable<T> @this, TObj klass, System.IObservable<T>? next = null, string? message = null)
            where TObj : Splat.IEnableLogger { }
        public static System.IObservable<T> LoggedCatch<T, TObj, TException>(this System.IObservable<T> @this, TObj klass, System.Func<TException, System.IObservable<T>> next, string? message = null)
            where TObj : Splat.IEnableLogger
            where TException : System.Exception { }
    }
    public static class ObservableMixins
    {
        public static System.IObservable<T> WhereNotNull<T>(this System.IObservable<T?> observable) { }
    }
    public class ObservedChange<TSender, TValue> : ReactiveUI.IObservedChange<TSender, TValue>
    {
        public ObservedChange(TSender sender, System.Linq.Expressions.Expression? expression, TValue value) { }
        public System.Linq.Expressions.Expression? Expression { get; }
        public TSender Sender { get; }
        public TValue Value { get; }
    }
    public static class ObservedChangedMixin
    {
        public static string GetPropertyName<TSender, TValue>(this ReactiveUI.IObservedChange<TSender, TValue> item) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static TValue GetValue<TSender, TValue>(this ReactiveUI.IObservedChange<TSender, TValue> item) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static TValue? GetValueOrDefault<TSender, TValue>(this ReactiveUI.IObservedChange<TSender, TValue> item) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<TValue> Value<TSender, TValue>(this System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> item) { }
    }
    public static class OrderedComparer
    {
        public static ReactiveUI.IComparerBuilder<T> For<T>() { }
        public static ReactiveUI.IComparerBuilder<T> For<T>(System.Collections.Generic.IEnumerable<T> enumerable) { }
    }
    public static class OrderedComparer<T>
    {
        public static System.Collections.Generic.IComparer<T> OrderBy<TValue>(System.Func<T, TValue> selector) { }
        public static System.Collections.Generic.IComparer<T> OrderBy<TValue>(System.Func<T, TValue> selector, System.Collections.Generic.IComparer<TValue> comparer) { }
        public static System.Collections.Generic.IComparer<T> OrderByDescending<TValue>(System.Func<T, TValue> selector) { }
        public static System.Collections.Generic.IComparer<T> OrderByDescending<TValue>(System.Func<T, TValue> selector, System.Collections.Generic.IComparer<TValue> comparer) { }
    }
    public sealed class POCOObservableForProperty : ReactiveUI.ICreatesObservableForProperty, Splat.IEnableLogger
    {
        public POCOObservableForProperty() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types which is not trim- or AOT-safe.")]
        public int GetAffinityForObject(System.Type type, string propertyName, bool beforeChanged = false) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types which is not trim- or AOT-safe.")]
        public System.IObservable<ReactiveUI.IObservedChange<object, object?>> GetNotificationForProperty(object sender, System.Linq.Expressions.Expression expression, string propertyName, bool beforeChanged = false, bool suppressWarnings = false) { }
    }
    public class PlatformRegistrations : ReactiveUI.IWantsToRegisterStuff
    {
        public PlatformRegistrations() { }
        public void Register(ReactiveUI.IRegistrar registrar) { }
    }
    [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("Uses dynamic binding paths which may require runtime code generation or reflectio" +
        "n-based invocation.")]
    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Uses reflection over runtime types and expression graphs which may be trimmed.")]
    public class PropertyBinderImplementation : ReactiveUI.IPropertyBinderImplementation, Splat.IEnableLogger
    {
        public PropertyBinderImplementation() { }
        [return: System.Runtime.CompilerServices.TupleElementNames(new string[] {
                "view",
                "isViewModel"})]
        public ReactiveUI.IReactiveBinding<TView, System.ValueTuple<object?, bool>> Bind<TViewModel, TView, TVMProp, TVProp, TDontCare>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, System.IObservable<TDontCare>? signalViewUpdate, System.Func<TVMProp?, TVProp> vmToViewConverter, System.Func<TVProp, TVMProp?> viewToVmConverter, ReactiveUI.TriggerUpdate triggerUpdate = 0)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        [return: System.Runtime.CompilerServices.TupleElementNames(new string?[]?[] {
                "view",
                "isViewModel"})]
        public ReactiveUI.IReactiveBinding<TView, System.ValueTuple<object?, bool>> Bind<TViewModel, TView, TVMProp, TVProp, TDontCare>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, System.IObservable<TDontCare>? signalViewUpdate, object? conversionHint, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null, ReactiveUI.IBindingTypeConverter? viewToVMConverterOverride = null, ReactiveUI.TriggerUpdate triggerUpdate = 0)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        public System.IDisposable BindTo<TValue, TTarget, TTValue>(System.IObservable<TValue> observedChange, TTarget? target, System.Linq.Expressions.Expression<System.Func<TTarget, TTValue?>> propertyExpression, object? conversionHint = null, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null)
            where TTarget :  class { }
        public ReactiveUI.IReactiveBinding<TView, TOut> OneWayBind<TViewModel, TView, TProp, TOut>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TProp>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TOut>> viewProperty, System.Func<TProp, TOut> selector)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        public ReactiveUI.IReactiveBinding<TView, TVProp> OneWayBind<TViewModel, TView, TVMProp, TVProp>(TViewModel? viewModel, TView view, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, object? conversionHint = null, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
    }
    [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("Uses dynamic binding paths which may require runtime code generation or reflectio" +
        "n-based invocation.")]
    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
    public static class PropertyBindingMixins
    {
        [return: System.Runtime.CompilerServices.TupleElementNames(new string[] {
                "view",
                "isViewModel"})]
        public static ReactiveUI.IReactiveBinding<TView, System.ValueTuple<object?, bool>> Bind<TViewModel, TView, TVMProp, TVProp>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, System.Func<TVMProp?, TVProp> vmToViewConverter, System.Func<TVProp, TVMProp?> viewToVmConverter)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        [return: System.Runtime.CompilerServices.TupleElementNames(new string?[]?[] {
                "view",
                "isViewModel"})]
        public static ReactiveUI.IReactiveBinding<TView, System.ValueTuple<object?, bool>> Bind<TViewModel, TView, TVMProp, TVProp>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, object? conversionHint = null, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null, ReactiveUI.IBindingTypeConverter? viewToVMConverterOverride = null)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        [return: System.Runtime.CompilerServices.TupleElementNames(new string[] {
                "view",
                "isViewModel"})]
        public static ReactiveUI.IReactiveBinding<TView, System.ValueTuple<object?, bool>> Bind<TViewModel, TView, TVMProp, TVProp, TDontCare>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, System.IObservable<TDontCare>? signalViewUpdate, System.Func<TVMProp?, TVProp> vmToViewConverter, System.Func<TVProp, TVMProp?> viewToVmConverter, ReactiveUI.TriggerUpdate triggerUpdate = 0)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        [return: System.Runtime.CompilerServices.TupleElementNames(new string?[]?[] {
                "view",
                "isViewModel"})]
        public static ReactiveUI.IReactiveBinding<TView, System.ValueTuple<object?, bool>> Bind<TViewModel, TView, TVMProp, TVProp, TDontCare>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, System.IObservable<TDontCare>? signalViewUpdate, object? conversionHint = null, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null, ReactiveUI.IBindingTypeConverter? viewToVMConverterOverride = null, ReactiveUI.TriggerUpdate triggerUpdate = 0)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        public static System.IDisposable BindTo<TValue, TTarget, TTValue>(this System.IObservable<TValue> @this, TTarget? target, System.Linq.Expressions.Expression<System.Func<TTarget, TTValue?>> property, object? conversionHint = null, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null)
            where TTarget :  class { }
        public static ReactiveUI.IReactiveBinding<TView, TOut> OneWayBind<TViewModel, TView, TProp, TOut>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TProp>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TOut>> viewProperty, System.Func<TProp, TOut> selector)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
        public static ReactiveUI.IReactiveBinding<TView, TVProp> OneWayBind<TViewModel, TView, TVMProp, TVProp>(this TView view, TViewModel? viewModel, System.Linq.Expressions.Expression<System.Func<TViewModel, TVMProp?>> vmProperty, System.Linq.Expressions.Expression<System.Func<TView, TVProp>> viewProperty, object? conversionHint = null, ReactiveUI.IBindingTypeConverter? vmToViewConverterOverride = null)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor { }
    }
    public static class ReactiveCommand
    {
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, System.Reactive.Unit> Create(System.Action execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, System.Reactive.Unit> Create<TParam>(System.Action<TParam> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, TResult> Create<TResult>(System.Func<TResult> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, TResult> Create<TParam, TResult>(System.Func<TParam, TResult> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.CombinedReactiveCommand<TParam, TResult> CreateCombined<TParam, TResult>(System.Collections.Generic.IEnumerable<ReactiveUI.ReactiveCommandBase<TParam, TResult>> childCommands, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, TResult> CreateFromObservable<TResult>(System.Func<System.IObservable<TResult>> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, TResult> CreateFromObservable<TParam, TResult>(System.Func<TParam, System.IObservable<TResult>> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, System.Reactive.Unit> CreateFromTask(System.Func<System.Threading.Tasks.Task> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, System.Reactive.Unit> CreateFromTask(System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, TResult> CreateFromTask<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, TResult> CreateFromTask<TResult>(System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task<TResult>> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, System.Reactive.Unit> CreateFromTask<TParam>(System.Func<TParam, System.Threading.Tasks.Task> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, System.Reactive.Unit> CreateFromTask<TParam>(System.Func<TParam, System.Threading.CancellationToken, System.Threading.Tasks.Task> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, TResult> CreateFromTask<TParam, TResult>(System.Func<TParam, System.Threading.Tasks.Task<TResult>> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, TResult> CreateFromTask<TParam, TResult>(System.Func<TParam, System.Threading.CancellationToken, System.Threading.Tasks.Task<TResult>> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, System.Reactive.Unit> CreateRunInBackground(System.Action execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? backgroundScheduler = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, System.Reactive.Unit> CreateRunInBackground<TParam>(System.Action<TParam> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? backgroundScheduler = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<System.Reactive.Unit, TResult> CreateRunInBackground<TResult>(System.Func<TResult> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? backgroundScheduler = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
        public static ReactiveUI.ReactiveCommand<TParam, TResult> CreateRunInBackground<TParam, TResult>(System.Func<TParam, TResult> execute, System.IObservable<bool>? canExecute = null, System.Reactive.Concurrency.IScheduler? backgroundScheduler = null, System.Reactive.Concurrency.IScheduler? outputScheduler = null) { }
    }
    public abstract class ReactiveCommandBase<TParam, TResult> : ReactiveUI.IHandleObservableErrors, ReactiveUI.IReactiveCommand, ReactiveUI.IReactiveCommand<TParam, TResult>, System.IDisposable, System.IObservable<TResult>, System.Windows.Input.ICommand
    {
        protected ReactiveCommandBase() { }
        public abstract System.IObservable<bool> CanExecute { get; }
        public abstract System.IObservable<bool> IsExecuting { get; }
        public abstract System.IObservable<System.Exception> ThrownExceptions { get; }
        public void Dispose() { }
        protected abstract void Dispose(bool disposing);
        public abstract System.IObservable<TResult> Execute();
        public abstract System.IObservable<TResult> Execute(TParam parameter);
        protected virtual bool ICommandCanExecute(object? parameter) { }
        protected virtual void ICommandExecute(object? parameter) { }
        protected void OnCanExecuteChanged(bool newValue) { }
        public abstract System.IDisposable Subscribe(System.IObserver<TResult> observer);
    }
    public static class ReactiveCommandMixins
    {
        public static System.IDisposable InvokeCommand<T>(this System.IObservable<T> item, System.Windows.Input.ICommand? command) { }
        public static System.IDisposable InvokeCommand<T, TResult>(this System.IObservable<T> item, ReactiveUI.ReactiveCommandBase<T, TResult>? command) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IDisposable InvokeCommand<T, TTarget>(this System.IObservable<T> item, TTarget? target, System.Linq.Expressions.Expression<System.Func<TTarget, System.Windows.Input.ICommand?>> commandProperty)
            where TTarget :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IDisposable InvokeCommand<T, TResult, TTarget>(this System.IObservable<T> item, TTarget? target, System.Linq.Expressions.Expression<System.Func<TTarget, ReactiveUI.ReactiveCommandBase<T, TResult>?>> commandProperty)
            where TTarget :  class { }
    }
    public class ReactiveCommand<TParam, TResult> : ReactiveUI.ReactiveCommandBase<TParam, TResult>
    {
        protected ReactiveCommand([System.Runtime.CompilerServices.TupleElementNames(new string?[]?[] {
                "Result",
                "Cancel"})] System.Func<TParam, System.IObservable<System.ValueTuple<System.IObservable<TResult>, System.Action>>> execute, System.IObservable<bool>? canExecute, System.Reactive.Concurrency.IScheduler? outputScheduler) { }
        protected ReactiveCommand(System.Func<TParam, System.IObservable<TResult>> execute, System.IObservable<bool>? canExecute, System.Reactive.Concurrency.IScheduler? outputScheduler) { }
        public override System.IObservable<bool> CanExecute { get; }
        public override System.IObservable<bool> IsExecuting { get; }
        public override System.IObservable<System.Exception> ThrownExceptions { get; }
        protected override void Dispose(bool disposing) { }
        public override System.IObservable<TResult> Execute() { }
        public override System.IObservable<TResult> Execute(TParam parameter) { }
        public override System.IDisposable Subscribe(System.IObserver<TResult> observer) { }
    }
    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Creating Expressions requires unreferenced code because the members being referen" +
        "ced by the Expression may be trimmed.")]
    public static class ReactiveNotifyPropertyChangedMixin
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> ObservableForProperty<TSender, TValue>(this TSender? item, System.Linq.Expressions.Expression<System.Func<TSender, TValue>> property) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Creating Expressions requires unreferenced code because the members being referen" +
            "ced by the Expression may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> ObservableForProperty<TSender, TValue>(this TSender? item, string propertyName) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> ObservableForProperty<TSender, TValue>(this TSender? item, System.Linq.Expressions.Expression<System.Func<TSender, TValue>> property, bool beforeChange) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Creating Expressions requires unreferenced code because the members being referen" +
            "ced by the Expression may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> ObservableForProperty<TSender, TValue>(this TSender? item, string propertyName, bool beforeChange) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> ObservableForProperty<TSender, TValue>(this TSender? item, System.Linq.Expressions.Expression<System.Func<TSender, TValue>> property, bool beforeChange, bool skipInitial) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Creating Expressions requires unreferenced code because the members being referen" +
            "ced by the Expression may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> ObservableForProperty<TSender, TValue>(this TSender? item, string propertyName, bool beforeChange, bool skipInitial) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> ObservableForProperty<TSender, TValue>(this TSender? item, System.Linq.Expressions.Expression<System.Func<TSender, TValue>> property, bool beforeChange, bool skipInitial, bool isDistinct) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Creating Expressions requires unreferenced code because the members being referen" +
            "ced by the Expression may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> ObservableForProperty<TSender, TValue>(this TSender? item, string propertyName, bool beforeChange, bool skipInitial, bool isDistinct) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<TRet> ObservableForProperty<TSender, TValue, TRet>(this TSender? item, System.Linq.Expressions.Expression<System.Func<TSender, TValue>> property, System.Func<TValue?, TRet> selector)
            where TSender :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<TRet> ObservableForProperty<TSender, TValue, TRet>(this TSender? item, System.Linq.Expressions.Expression<System.Func<TSender, TValue>> property, System.Func<TValue?, TRet> selector, bool beforeChange)
            where TSender :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> SubscribeToExpressionChain<TSender, TValue>(this TSender? source, System.Linq.Expressions.Expression? expression) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> SubscribeToExpressionChain<TSender, TValue>(this TSender? source, System.Linq.Expressions.Expression? expression, bool beforeChange) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> SubscribeToExpressionChain<TSender, TValue>(this TSender? source, System.Linq.Expressions.Expression? expression, bool beforeChange, bool skipInitial) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> SubscribeToExpressionChain<TSender, TValue>(this TSender? source, System.Linq.Expressions.Expression? expression, bool beforeChange, bool skipInitial, bool suppressWarnings) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IObservable<ReactiveUI.IObservedChange<TSender, TValue>> SubscribeToExpressionChain<TSender, TValue>(this TSender? source, System.Linq.Expressions.Expression? expression, bool beforeChange, bool skipInitial, bool suppressWarnings, bool isDistinct) { }
    }
    [System.Runtime.Serialization.DataContract]
    public class ReactiveObject : ReactiveUI.IHandleObservableErrors, ReactiveUI.IReactiveNotifyPropertyChanged<ReactiveUI.IReactiveObject>, ReactiveUI.IReactiveObject, Splat.IEnableLogger, System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.INotifyPropertyChanging
    {
        public ReactiveObject() { }
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DataAnnotations.Display(AutoGenerateField=false, AutoGenerateFilter=false, Order=-1)]
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.IObservable<ReactiveUI.IReactivePropertyChangedEventArgs<ReactiveUI.IReactiveObject>> Changed { get; }
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DataAnnotations.Display(AutoGenerateField=false, AutoGenerateFilter=false, Order=-1)]
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.IObservable<ReactiveUI.IReactivePropertyChangedEventArgs<ReactiveUI.IReactiveObject>> Changing { get; }
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DataAnnotations.Display(AutoGenerateField=false, AutoGenerateFilter=false, Order=-1)]
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.IObservable<System.Exception> ThrownExceptions { get; }
        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;
        public event System.ComponentModel.PropertyChangingEventHandler? PropertyChanging;
        public bool AreChangeNotificationsEnabled() { }
        public System.IDisposable DelayChangeNotifications() { }
        public System.IDisposable SuppressChangeNotifications() { }
    }
    public class ReactivePropertyChangedEventArgs<TSender> : System.ComponentModel.PropertyChangedEventArgs, ReactiveUI.IReactivePropertyChangedEventArgs<TSender>
    {
        public ReactivePropertyChangedEventArgs(TSender sender, string propertyName) { }
        public TSender Sender { get; }
    }
    public class ReactivePropertyChangingEventArgs<TSender> : System.ComponentModel.PropertyChangingEventArgs, ReactiveUI.IReactivePropertyChangedEventArgs<TSender>
    {
        public ReactivePropertyChangingEventArgs(TSender sender, string? propertyName) { }
        public TSender Sender { get; }
    }
    public static class ReactivePropertyMixins
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("DataAnnotations validation uses reflection to discover attributes and is not trim" +
            "-safe. Use manual validation for AOT scenarios.")]
        public static ReactiveUI.ReactiveProperty<T> AddValidation<T>(this ReactiveUI.ReactiveProperty<T> self, System.Linq.Expressions.Expression<System.Func<ReactiveUI.ReactiveProperty<T>?>> selfSelector) { }
        public static System.IObservable<string?> ObserveValidationErrors<T>(this ReactiveUI.ReactiveProperty<T> self) { }
    }
    [System.Runtime.Serialization.DataContract]
    public class ReactiveProperty<T> : ReactiveUI.ReactiveObject, ReactiveUI.IReactiveProperty<T>, System.ComponentModel.INotifyDataErrorInfo, System.ComponentModel.INotifyPropertyChanged, System.IDisposable, System.IObservable<T?>, System.Reactive.Disposables.ICancelable
    {
        public ReactiveProperty() { }
        public ReactiveProperty(T? initialValue) { }
        public ReactiveProperty(T? initialValue, bool skipCurrentValueOnSubscribe, bool allowDuplicateValues) { }
        public ReactiveProperty(T? initialValue, System.Reactive.Concurrency.IScheduler? scheduler, bool skipCurrentValueOnSubscribe, bool allowDuplicateValues) { }
        public bool HasErrors { get; }
        public bool IsDisposed { get; }
        public System.IObservable<System.Collections.IEnumerable?> ObserveErrorChanged { get; }
        public System.IObservable<bool> ObserveHasErrors { get; }
        [System.Runtime.Serialization.DataMember]
        [System.Text.Json.Serialization.JsonInclude]
        public T Value { get; set; }
        public event System.EventHandler<System.ComponentModel.DataErrorsChangedEventArgs>? ErrorsChanged;
        public ReactiveUI.ReactiveProperty<T> AddValidationError(System.Func<System.IObservable<T?>, System.IObservable<System.Collections.IEnumerable?>> validator, bool ignoreInitialError = false) { }
        public ReactiveUI.ReactiveProperty<T> AddValidationError(System.Func<System.IObservable<T?>, System.IObservable<string?>> validator, bool ignoreInitialError = false) { }
        public ReactiveUI.ReactiveProperty<T> AddValidationError(System.Func<T?, System.Collections.IEnumerable?> validator, bool ignoreInitialError = false) { }
        public ReactiveUI.ReactiveProperty<T> AddValidationError(System.Func<T?, System.Threading.Tasks.Task<System.Collections.IEnumerable?>> validator, bool ignoreInitialError = false) { }
        public ReactiveUI.ReactiveProperty<T> AddValidationError(System.Func<T?, System.Threading.Tasks.Task<string?>> validator, bool ignoreInitialError = false) { }
        public ReactiveUI.ReactiveProperty<T> AddValidationError(System.Func<T?, string?> validator, bool ignoreInitialError = false) { }
        public void CheckValidation() { }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
        public System.Collections.IEnumerable? GetErrors(string? propertyName) { }
        public void Refresh() { }
        public System.IDisposable Subscribe(System.IObserver<T?> observer) { }
        public static ReactiveUI.ReactiveProperty<T> Create() { }
        public static ReactiveUI.ReactiveProperty<T> Create(T? initialValue) { }
        public static ReactiveUI.ReactiveProperty<T> Create(T? initialValue, bool skipCurrentValueOnSubscribe, bool allowDuplicateValues) { }
        public static ReactiveUI.ReactiveProperty<T> Create(T? initialValue, System.Reactive.Concurrency.IScheduler scheduler, bool skipCurrentValueOnSubscribe, bool allowDuplicateValues) { }
    }
    [System.Runtime.Serialization.DataContract]
    public class ReactiveRecord : ReactiveUI.IHandleObservableErrors, ReactiveUI.IReactiveNotifyPropertyChanged<ReactiveUI.IReactiveObject>, ReactiveUI.IReactiveObject, Splat.IEnableLogger, System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.INotifyPropertyChanging, System.IEquatable<ReactiveUI.ReactiveRecord>
    {
        public ReactiveRecord() { }
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DataAnnotations.Display(AutoGenerateField=false, AutoGenerateFilter=false, Order=-1)]
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.IObservable<ReactiveUI.IReactivePropertyChangedEventArgs<ReactiveUI.IReactiveObject>> Changed { get; }
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DataAnnotations.Display(AutoGenerateField=false, AutoGenerateFilter=false, Order=-1)]
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.IObservable<ReactiveUI.IReactivePropertyChangedEventArgs<ReactiveUI.IReactiveObject>> Changing { get; }
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DataAnnotations.Display(AutoGenerateField=false, AutoGenerateFilter=false, Order=-1)]
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.IObservable<System.Exception> ThrownExceptions { get; }
        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;
        public event System.ComponentModel.PropertyChangingEventHandler? PropertyChanging;
        public bool AreChangeNotificationsEnabled() { }
        public System.IDisposable DelayChangeNotifications() { }
        public System.IDisposable SuppressChangeNotifications() { }
    }
    public static class Reflection
    {
        public static string ExpressionToPropertyNames(System.Linq.Expressions.Expression? expression) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Reflects over custom delegate Invoke signature; members may be trimmed.")]
        public static System.Type GetEventArgsTypeForEvent([System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)] System.Type type, string? eventName) { }
        public static System.Func<object?, object?[]?, object?>? GetValueFetcherForProperty(System.Reflection.MemberInfo? member) { }
        public static System.Func<object?, object?[]?, object?> GetValueFetcherOrThrow(System.Reflection.MemberInfo? member) { }
        public static System.Action<object?, object?, object?[]?>? GetValueSetterForProperty(System.Reflection.MemberInfo? member) { }
        public static System.Action<object?, object?, object?[]?> GetValueSetterOrThrow(System.Reflection.MemberInfo? member) { }
        public static bool IsStatic(this System.Reflection.PropertyInfo item) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Resolves types by name and loads assemblies; types may be trimmed.")]
        public static System.Type? ReallyFindType(string? type, bool throwOnFailure) { }
        public static System.Linq.Expressions.Expression Rewrite(System.Linq.Expressions.Expression? expression) { }
        public static void ThrowIfMethodsNotOverloaded(string callingTypeName, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)] System.Type targetType, params string[] methodsToCheck) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Inspects declared methods on a runtime type; members may be trimmed.")]
        public static void ThrowIfMethodsNotOverloaded(string callingTypeName, object targetObject, params string[] methodsToCheck) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static bool TryGetAllValuesForPropertyChain(out ReactiveUI.IObservedChange<object, object?>[] changeValues, object? current, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression> expressionChain) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static bool TryGetValueForPropertyChain<TValue>(out TValue changeValue, object? current, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression> expressionChain) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static bool TrySetValueToPropertyChain<TValue>(object? target, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression> expressionChain, TValue value, bool shouldThrow = true) { }
    }
    public class Registrations : ReactiveUI.IWantsToRegisterStuff
    {
        public Registrations() { }
        public void Register(ReactiveUI.IRegistrar registrar) { }
    }
    public static class RoutableViewModelMixin
    {
        public static System.IDisposable WhenNavigatedTo(this ReactiveUI.IRoutableViewModel item, System.Func<System.IDisposable> onNavigatedTo) { }
        public static System.IObservable<System.Reactive.Unit> WhenNavigatedToObservable(this ReactiveUI.IRoutableViewModel item) { }
        public static System.IObservable<System.Reactive.Unit> WhenNavigatingFromObservable(this ReactiveUI.IRoutableViewModel item) { }
    }
    [System.Runtime.Serialization.DataContract]
    public class RoutingState : ReactiveUI.ReactiveObject
    {
        public RoutingState(System.Reactive.Concurrency.IScheduler? scheduler = null) { }
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.IObservable<ReactiveUI.IRoutableViewModel> CurrentViewModel { get; protected set; }
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public ReactiveUI.ReactiveCommand<ReactiveUI.IRoutableViewModel, ReactiveUI.IRoutableViewModel> Navigate { get; protected set; }
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public ReactiveUI.ReactiveCommand<ReactiveUI.IRoutableViewModel, ReactiveUI.IRoutableViewModel> NavigateAndReset { get; protected set; }
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public ReactiveUI.ReactiveCommand<System.Reactive.Unit, ReactiveUI.IRoutableViewModel> NavigateBack { get; protected set; }
        [System.Runtime.Serialization.IgnoreDataMember]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.IObservable<DynamicData.IChangeSet<ReactiveUI.IRoutableViewModel>> NavigationChanged { get; protected set; }
        [System.Runtime.Serialization.DataMember]
        [System.Text.Json.Serialization.JsonRequired]
        public System.Collections.ObjectModel.ObservableCollection<ReactiveUI.IRoutableViewModel> NavigationStack { get; set; }
    }
    public static class RoutingStateMixins
    {
        public static T? FindViewModelInStack<T>(this ReactiveUI.RoutingState item)
            where T : ReactiveUI.IRoutableViewModel { }
        public static ReactiveUI.IRoutableViewModel? GetCurrentViewModel(this ReactiveUI.RoutingState item) { }
    }
    public static class RxCacheSize
    {
        public static int BigCacheLimit { get; }
        public static int SmallCacheLimit { get; }
    }
    public static class RxSchedulers
    {
        public static System.Reactive.Concurrency.IScheduler MainThreadScheduler { get; set; }
        public static bool SuppressViewCommandBindingMessage { get; set; }
        public static System.Reactive.Concurrency.IScheduler TaskpoolScheduler { get; set; }
    }
    public static class RxState
    {
        public static System.IObserver<System.Exception> DefaultExceptionHandler { get; }
    }
    public static class RxSuspension
    {
        public static ReactiveUI.ISuspensionHost SuspensionHost { get; }
    }
    public class ScheduledSubject<T> : System.IDisposable, System.IObservable<T>, System.IObserver<T>, System.Reactive.Subjects.ISubject<T>, System.Reactive.Subjects.ISubject<T, T>
    {
        public ScheduledSubject(System.Reactive.Concurrency.IScheduler scheduler, System.IObserver<T>? defaultObserver = null, System.Reactive.Subjects.ISubject<T>? defaultSubject = null) { }
        public void Dispose() { }
        protected virtual void Dispose(bool isDisposing) { }
        public void OnCompleted() { }
        public void OnError(System.Exception error) { }
        public void OnNext(T value) { }
        public System.IDisposable Subscribe(System.IObserver<T> observer) { }
    }
    public sealed class ShortToStringTypeConverter : ReactiveUI.BindingTypeConverter<short, string>
    {
        public ShortToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(short from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class SingleInstanceViewAttribute : System.Attribute
    {
        public SingleInstanceViewAttribute() { }
    }
    public sealed class SingleToStringTypeConverter : ReactiveUI.BindingTypeConverter<float, string>
    {
        public SingleToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(float from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class StringConverter : ReactiveUI.IBindingTypeConverter, Splat.IEnableLogger
    {
        public StringConverter() { }
        public System.Type FromType { get; }
        public System.Type ToType { get; }
        public int GetAffinityForObjects() { }
        public bool TryConvertTyped(object? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out object? result) { }
    }
    public sealed class StringToBooleanTypeConverter : ReactiveUI.BindingTypeConverter<string, bool>
    {
        public StringToBooleanTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out bool result) { }
    }
    public sealed class StringToByteTypeConverter : ReactiveUI.BindingTypeConverter<string, byte>
    {
        public StringToByteTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out byte result) { }
    }
    public sealed class StringToDateOnlyTypeConverter : ReactiveUI.BindingTypeConverter<string, System.DateOnly>
    {
        public StringToDateOnlyTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.DateOnly result) { }
    }
    public sealed class StringToDateTimeOffsetTypeConverter : ReactiveUI.BindingTypeConverter<string, System.DateTimeOffset>
    {
        public StringToDateTimeOffsetTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.DateTimeOffset result) { }
    }
    public sealed class StringToDateTimeTypeConverter : ReactiveUI.BindingTypeConverter<string, System.DateTime>
    {
        public StringToDateTimeTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.DateTime result) { }
    }
    public sealed class StringToDecimalTypeConverter : ReactiveUI.BindingTypeConverter<string, decimal>
    {
        public StringToDecimalTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out decimal result) { }
    }
    public sealed class StringToDoubleTypeConverter : ReactiveUI.BindingTypeConverter<string, double>
    {
        public StringToDoubleTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out double result) { }
    }
    public sealed class StringToGuidTypeConverter : ReactiveUI.BindingTypeConverter<string, System.Guid>
    {
        public StringToGuidTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.Guid result) { }
    }
    public sealed class StringToIntegerTypeConverter : ReactiveUI.BindingTypeConverter<string, int>
    {
        public StringToIntegerTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out int result) { }
    }
    public sealed class StringToLongTypeConverter : ReactiveUI.BindingTypeConverter<string, long>
    {
        public StringToLongTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out long result) { }
    }
    public sealed class StringToNullableBooleanTypeConverter : ReactiveUI.BindingTypeConverter<string, bool?>
    {
        public StringToNullableBooleanTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out bool? result) { }
    }
    public sealed class StringToNullableByteTypeConverter : ReactiveUI.BindingTypeConverter<string, byte?>
    {
        public StringToNullableByteTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out byte? result) { }
    }
    public sealed class StringToNullableDateOnlyTypeConverter : ReactiveUI.BindingTypeConverter<string, System.DateOnly?>
    {
        public StringToNullableDateOnlyTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.DateOnly? result) { }
    }
    public sealed class StringToNullableDateTimeOffsetTypeConverter : ReactiveUI.BindingTypeConverter<string, System.DateTimeOffset?>
    {
        public StringToNullableDateTimeOffsetTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.DateTimeOffset? result) { }
    }
    public sealed class StringToNullableDateTimeTypeConverter : ReactiveUI.BindingTypeConverter<string, System.DateTime?>
    {
        public StringToNullableDateTimeTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.DateTime? result) { }
    }
    public sealed class StringToNullableDecimalTypeConverter : ReactiveUI.BindingTypeConverter<string, decimal?>
    {
        public StringToNullableDecimalTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out decimal? result) { }
    }
    public sealed class StringToNullableDoubleTypeConverter : ReactiveUI.BindingTypeConverter<string, double?>
    {
        public StringToNullableDoubleTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out double? result) { }
    }
    public sealed class StringToNullableGuidTypeConverter : ReactiveUI.BindingTypeConverter<string, System.Guid?>
    {
        public StringToNullableGuidTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.Guid? result) { }
    }
    public sealed class StringToNullableIntegerTypeConverter : ReactiveUI.BindingTypeConverter<string, int?>
    {
        public StringToNullableIntegerTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out int? result) { }
    }
    public sealed class StringToNullableLongTypeConverter : ReactiveUI.BindingTypeConverter<string, long?>
    {
        public StringToNullableLongTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out long? result) { }
    }
    public sealed class StringToNullableShortTypeConverter : ReactiveUI.BindingTypeConverter<string, short?>
    {
        public StringToNullableShortTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out short? result) { }
    }
    public sealed class StringToNullableSingleTypeConverter : ReactiveUI.BindingTypeConverter<string, float?>
    {
        public StringToNullableSingleTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out float? result) { }
    }
    public sealed class StringToNullableTimeOnlyTypeConverter : ReactiveUI.BindingTypeConverter<string, System.TimeOnly?>
    {
        public StringToNullableTimeOnlyTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.TimeOnly? result) { }
    }
    public sealed class StringToNullableTimeSpanTypeConverter : ReactiveUI.BindingTypeConverter<string, System.TimeSpan?>
    {
        public StringToNullableTimeSpanTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.TimeSpan? result) { }
    }
    public sealed class StringToShortTypeConverter : ReactiveUI.BindingTypeConverter<string, short>
    {
        public StringToShortTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out short result) { }
    }
    public sealed class StringToSingleTypeConverter : ReactiveUI.BindingTypeConverter<string, float>
    {
        public StringToSingleTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out float result) { }
    }
    public sealed class StringToTimeOnlyTypeConverter : ReactiveUI.BindingTypeConverter<string, System.TimeOnly>
    {
        public StringToTimeOnlyTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.TimeOnly result) { }
    }
    public sealed class StringToTimeSpanTypeConverter : ReactiveUI.BindingTypeConverter<string, System.TimeSpan>
    {
        public StringToTimeSpanTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.TimeSpan result) { }
    }
    public sealed class StringToUriTypeConverter : ReactiveUI.BindingTypeConverter<string, System.Uri>
    {
        public StringToUriTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(string? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.Uri? result) { }
    }
    public static class SuspensionHostExtensions
    {
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode(@"This overload may invoke ISuspensionDriver.LoadState(), which is commonly reflection-based. Prefer GetAppState<TAppState>(ISuspensionHost<TAppState>) used with SetupDefaultSuspendResume<TAppState>(..., JsonTypeInfo<TAppState>, ...) for trimming/AOT scenarios.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode(@"This overload may invoke ISuspensionDriver.LoadState(), which is commonly reflection-based. Prefer GetAppState<TAppState>(ISuspensionHost<TAppState>) used with SetupDefaultSuspendResume<TAppState>(..., JsonTypeInfo<TAppState>, ...) for trimming/AOT scenarios.")]
        public static T GetAppState<T>(this ReactiveUI.ISuspensionHost item) { }
        public static TAppState GetAppState<TAppState>(this ReactiveUI.Interfaces.ISuspensionHost<TAppState> item)
            where TAppState :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("This overload uses WhenAny, which can require unreferenced/dynamic code in trimmi" +
            "ng/AOT scenarios. Prefer ObserveAppState<TAppState>(ISuspensionHost<TAppState>) " +
            "for trimming/AOT scenarios.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("This overload uses WhenAny, which can require unreferenced/dynamic code in trimmi" +
            "ng/AOT scenarios. Prefer ObserveAppState<TAppState>(ISuspensionHost<TAppState>) " +
            "for trimming/AOT scenarios.")]
        public static System.IObservable<T> ObserveAppState<T>(this ReactiveUI.ISuspensionHost item)
            where T :  class { }
        public static System.IObservable<TAppState> ObserveAppState<TAppState>(this ReactiveUI.Interfaces.ISuspensionHost<TAppState> item)
            where TAppState :  class { }
        [System.Diagnostics.CodeAnalysis.RequiresDynamicCode("This overload may invoke ISuspensionDriver.LoadState()/SaveState<T>(T), which are" +
            " commonly reflection-based. Prefer SetupDefaultSuspendResume<TAppState>(..., Jso" +
            "nTypeInfo<TAppState>, ...) for trimming/AOT scenarios.")]
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("This overload may invoke ISuspensionDriver.LoadState()/SaveState<T>(T), which are" +
            " commonly reflection-based. Prefer SetupDefaultSuspendResume<TAppState>(..., Jso" +
            "nTypeInfo<TAppState>, ...) for trimming/AOT scenarios.")]
        public static System.IDisposable SetupDefaultSuspendResume(this ReactiveUI.ISuspensionHost item, ReactiveUI.ISuspensionDriver? driver = null) { }
        public static System.IDisposable SetupDefaultSuspendResume<TAppState>(this ReactiveUI.Interfaces.ISuspensionHost<TAppState> item, System.Text.Json.Serialization.Metadata.JsonTypeInfo<TAppState> typeInfo, ReactiveUI.ISuspensionDriver? driver = null)
            where TAppState :  class { }
    }
    public class SuspensionHost<TAppState> : ReactiveUI.ReactiveObject, ReactiveUI.IReactiveObject, ReactiveUI.ISuspensionHost, ReactiveUI.Interfaces.ISuspensionHost<TAppState>, Splat.IEnableLogger, System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.INotifyPropertyChanging, System.IDisposable
    {
        public SuspensionHost() { }
        public TAppState AppStateValue { get; set; }
        public System.IObservable<TAppState?> AppStateValueChanged { get; }
        public System.Func<TAppState>? CreateNewAppStateTyped { get; set; }
        public System.IObservable<System.Reactive.Unit> IsContinuing { get; set; }
        public System.IObservable<System.Reactive.Unit> IsLaunchingNew { get; set; }
        public System.IObservable<System.Reactive.Unit> IsResuming { get; set; }
        public System.IObservable<System.Reactive.Unit> IsUnpausing { get; set; }
        public System.IObservable<System.Reactive.Unit> ShouldInvalidateState { get; set; }
        public System.IObservable<System.IDisposable> ShouldPersistState { get; set; }
        public void Dispose() { }
        protected virtual void Dispose(bool disposing) { }
    }
    public sealed class TimeOnlyToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.TimeOnly, string>
    {
        public TimeOnlyToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.TimeOnly from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public sealed class TimeSpanToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.TimeSpan, string>
    {
        public TimeSpanToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.TimeSpan from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    public enum TriggerUpdate
    {
        ViewToViewModel = 0,
        ViewModelToView = 1,
    }
    public class UnhandledErrorException : System.Exception
    {
        public UnhandledErrorException() { }
        public UnhandledErrorException(string message) { }
        public UnhandledErrorException(string message, System.Exception innerException) { }
    }
    public class UnhandledInteractionException<TInput, TOutput> : System.Exception
    {
        public UnhandledInteractionException() { }
        public UnhandledInteractionException(string message) { }
        public UnhandledInteractionException(ReactiveUI.Interaction<TInput, TOutput> interaction, TInput input) { }
        public UnhandledInteractionException(string message, System.Exception innerException) { }
        public TInput Input { get; }
        public ReactiveUI.Interaction<TInput, TOutput>? Interaction { get; }
    }
    public sealed class UriToStringTypeConverter : ReactiveUI.BindingTypeConverter<System.Uri, string>
    {
        public UriToStringTypeConverter() { }
        public override int GetAffinityForObjects() { }
        public override bool TryConvert(System.Uri? from, object? conversionHint, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? result) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class ViewContractAttribute : System.Attribute
    {
        public ViewContractAttribute(string contract) { }
        public string Contract { get; }
    }
    public static class ViewForMixins
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IDisposable WhenActivated(this ReactiveUI.IActivatableView item, System.Action<System.Action<System.IDisposable>> block) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IDisposable WhenActivated(this ReactiveUI.IActivatableView item, System.Func<System.Collections.Generic.IEnumerable<System.IDisposable>> block) { }
        public static void WhenActivated(this ReactiveUI.IActivatableViewModel item, System.Action<System.Action<System.IDisposable>> block) { }
        public static void WhenActivated(this ReactiveUI.IActivatableViewModel item, System.Action<System.Reactive.Disposables.CompositeDisposable> block) { }
        public static void WhenActivated(this ReactiveUI.IActivatableViewModel item, System.Func<System.Collections.Generic.IEnumerable<System.IDisposable>> block) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IDisposable WhenActivated(this ReactiveUI.IActivatableView item, System.Action<System.Action<System.IDisposable>> block, ReactiveUI.IViewFor view) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IDisposable WhenActivated(this ReactiveUI.IActivatableView item, System.Action<System.Reactive.Disposables.CompositeDisposable> block, ReactiveUI.IViewFor? view = null) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
        public static System.IDisposable WhenActivated(this ReactiveUI.IActivatableView item, System.Func<System.Collections.Generic.IEnumerable<System.IDisposable>> block, ReactiveUI.IViewFor? view) { }
    }
    public static class ViewLocator
    {
        public static ReactiveUI.IViewLocator Current { get; }
    }
    public class ViewLocatorNotFoundException : System.Exception
    {
        public ViewLocatorNotFoundException() { }
        public ViewLocatorNotFoundException(string message) { }
        public ViewLocatorNotFoundException(string message, System.Exception innerException) { }
    }
    public sealed class ViewMappingBuilder
    {
        public ReactiveUI.ViewMappingBuilder Map<TViewModel, TView>(string? contract = null)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new () { }
        public ReactiveUI.ViewMappingBuilder Map<TViewModel, TView>(System.Func<TView> factory, string? contract = null)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor<TViewModel> { }
        public ReactiveUI.ViewMappingBuilder MapFromServiceLocator<TViewModel, TView>(string? contract = null)
            where TViewModel :  class
            where TView :  class, ReactiveUI.IViewFor<TViewModel> { }
    }
    public sealed class ViewModelActivator : System.IDisposable
    {
        public ViewModelActivator() { }
        public System.IObservable<System.Reactive.Unit> Activated { get; }
        public System.IObservable<System.Reactive.Unit> Deactivated { get; }
        public System.IDisposable Activate() { }
        public void Deactivate(bool ignoreRefCount = false) { }
        public void Dispose() { }
    }
    public class WaitForDispatcherScheduler : System.Reactive.Concurrency.IScheduler
    {
        public WaitForDispatcherScheduler(System.Func<System.Reactive.Concurrency.IScheduler> schedulerFactory) { }
        public System.DateTimeOffset Now { get; }
        public System.IDisposable Schedule<TState>(TState state, System.Func<System.Reactive.Concurrency.IScheduler, TState, System.IDisposable> action) { }
        public System.IDisposable Schedule<TState>(TState state, System.DateTimeOffset dueTime, System.Func<System.Reactive.Concurrency.IScheduler, TState, System.IDisposable> action) { }
        public System.IDisposable Schedule<TState>(TState state, System.TimeSpan dueTime, System.Func<System.Reactive.Concurrency.IScheduler, TState, System.IDisposable> action) { }
    }
    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
    public static class WhenAnyMixin
    {
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Func<ReactiveUI.IObservedChange<TSender, T1>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1>(this TSender? sender, string property1Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Func<ReactiveUI.IObservedChange<TSender, T1>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1>(this TSender? sender, string property1Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2>(this TSender? sender, string property1Name, string property2Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2>(this TSender? sender, string property1Name, string property2Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3>(this TSender? sender, string property1Name, string property2Name, string property3Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3>(this TSender? sender, string property1Name, string property2Name, string property3Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Linq.Expressions.Expression<System.Func<TSender, T11>> property11, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, ReactiveUI.IObservedChange<TSender, T11>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, string property11Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, ReactiveUI.IObservedChange<TSender, T11>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Linq.Expressions.Expression<System.Func<TSender, T11>> property11, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, ReactiveUI.IObservedChange<TSender, T11>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, string property11Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, ReactiveUI.IObservedChange<TSender, T11>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Linq.Expressions.Expression<System.Func<TSender, T11>> property11, System.Linq.Expressions.Expression<System.Func<TSender, T12>> property12, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, ReactiveUI.IObservedChange<TSender, T11>, ReactiveUI.IObservedChange<TSender, T12>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, string property11Name, string property12Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, ReactiveUI.IObservedChange<TSender, T11>, ReactiveUI.IObservedChange<TSender, T12>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Linq.Expressions.Expression<System.Func<TSender, T11>> property11, System.Linq.Expressions.Expression<System.Func<TSender, T12>> property12, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, ReactiveUI.IObservedChange<TSender, T11>, ReactiveUI.IObservedChange<TSender, T12>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAny<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, string property11Name, string property12Name, System.Func<ReactiveUI.IObservedChange<TSender, T1>, ReactiveUI.IObservedChange<TSender, T2>, ReactiveUI.IObservedChange<TSender, T3>, ReactiveUI.IObservedChange<TSender, T4>, ReactiveUI.IObservedChange<TSender, T5>, ReactiveUI.IObservedChange<TSender, T6>, ReactiveUI.IObservedChange<TSender, T7>, ReactiveUI.IObservedChange<TSender, T8>, ReactiveUI.IObservedChange<TSender, T9>, ReactiveUI.IObservedChange<TSender, T10>, ReactiveUI.IObservedChange<TSender, T11>, ReactiveUI.IObservedChange<TSender, T12>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Linq.Expressions.Expression? property9, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Linq.Expressions.Expression? property9, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Linq.Expressions.Expression? property9, System.Linq.Expressions.Expression? property10, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Linq.Expressions.Expression? property9, System.Linq.Expressions.Expression? property10, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Linq.Expressions.Expression? property9, System.Linq.Expressions.Expression? property10, System.Linq.Expressions.Expression? property11, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Linq.Expressions.Expression? property9, System.Linq.Expressions.Expression? property10, System.Linq.Expressions.Expression? property11, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Linq.Expressions.Expression? property9, System.Linq.Expressions.Expression? property10, System.Linq.Expressions.Expression? property11, System.Linq.Expressions.Expression? property12, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyDynamic<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression? property1, System.Linq.Expressions.Expression? property2, System.Linq.Expressions.Expression? property3, System.Linq.Expressions.Expression? property4, System.Linq.Expressions.Expression? property5, System.Linq.Expressions.Expression? property6, System.Linq.Expressions.Expression? property7, System.Linq.Expressions.Expression? property8, System.Linq.Expressions.Expression? property9, System.Linq.Expressions.Expression? property10, System.Linq.Expressions.Expression? property11, System.Linq.Expressions.Expression? property12, System.Func<ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, ReactiveUI.IObservedChange<TSender?, object?>, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, TRet>> property1) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet>(this TSender? sender, string propertyName) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, TRet>> property1, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet>(this TSender? sender, string propertyName, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Func<T1, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2>> WhenAnyValue<TSender, T1, T2>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1>(this TSender? sender, string property1Name, System.Func<T1, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2>> WhenAnyValue<TSender, T1, T2>(this TSender? sender, string property1Name, string property2Name) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Func<T1, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2>> WhenAnyValue<TSender, T1, T2>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1>(this TSender? sender, string property1Name, System.Func<T1, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2>> WhenAnyValue<TSender, T1, T2>(this TSender? sender, string property1Name, string property2Name, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Func<T1, T2, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3>> WhenAnyValue<TSender, T1, T2, T3>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2>(this TSender? sender, string property1Name, string property2Name, System.Func<T1, T2, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3>> WhenAnyValue<TSender, T1, T2, T3>(this TSender? sender, string property1Name, string property2Name, string property3Name) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Func<T1, T2, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3>> WhenAnyValue<TSender, T1, T2, T3>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2>(this TSender? sender, string property1Name, string property2Name, System.Func<T1, T2, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3>> WhenAnyValue<TSender, T1, T2, T3>(this TSender? sender, string property1Name, string property2Name, string property3Name, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Func<T1, T2, T3, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4>> WhenAnyValue<TSender, T1, T2, T3, T4>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3>(this TSender? sender, string property1Name, string property2Name, string property3Name, System.Func<T1, T2, T3, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4>> WhenAnyValue<TSender, T1, T2, T3, T4>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Func<T1, T2, T3, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4>> WhenAnyValue<TSender, T1, T2, T3, T4>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3>(this TSender? sender, string property1Name, string property2Name, string property3Name, System.Func<T1, T2, T3, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4>> WhenAnyValue<TSender, T1, T2, T3, T4>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Func<T1, T2, T3, T4, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5>> WhenAnyValue<TSender, T1, T2, T3, T4, T5>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, System.Func<T1, T2, T3, T4, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5>> WhenAnyValue<TSender, T1, T2, T3, T4, T5>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Func<T1, T2, T3, T4, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5>> WhenAnyValue<TSender, T1, T2, T3, T4, T5>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, System.Func<T1, T2, T3, T4, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5>> WhenAnyValue<TSender, T1, T2, T3, T4, T5>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Func<T1, T2, T3, T4, T5, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5, T6>> WhenAnyValue<TSender, T1, T2, T3, T4, T5, T6>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, System.Func<T1, T2, T3, T4, T5, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5, T6>> WhenAnyValue<TSender, T1, T2, T3, T4, T5, T6>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Func<T1, T2, T3, T4, T5, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5, T6>> WhenAnyValue<TSender, T1, T2, T3, T4, T5, T6>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, System.Func<T1, T2, T3, T4, T5, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5, T6>> WhenAnyValue<TSender, T1, T2, T3, T4, T5, T6>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Func<T1, T2, T3, T4, T5, T6, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7>> WhenAnyValue<TSender, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, System.Func<T1, T2, T3, T4, T5, T6, TRet> selector) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7>> WhenAnyValue<TSender, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Func<T1, T2, T3, T4, T5, T6, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7>> WhenAnyValue<TSender, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, System.Func<T1, T2, T3, T4, T5, T6, TRet> selector, bool isDistinct) { }
        public static System.IObservable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7>> WhenAnyValue<TSender, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Func<T1, T2, T3, T4, T5, T6, T7, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, System.Func<T1, T2, T3, T4, T5, T6, T7, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Func<T1, T2, T3, T4, T5, T6, T7, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, System.Func<T1, T2, T3, T4, T5, T6, T7, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Linq.Expressions.Expression<System.Func<TSender, T11>> property11, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, string property11Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Linq.Expressions.Expression<System.Func<TSender, T11>> property11, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, string property11Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Linq.Expressions.Expression<System.Func<TSender, T11>> property11, System.Linq.Expressions.Expression<System.Func<TSender, T12>> property12, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, string property11Name, string property12Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TRet> selector) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, T1>> property1, System.Linq.Expressions.Expression<System.Func<TSender, T2>> property2, System.Linq.Expressions.Expression<System.Func<TSender, T3>> property3, System.Linq.Expressions.Expression<System.Func<TSender, T4>> property4, System.Linq.Expressions.Expression<System.Func<TSender, T5>> property5, System.Linq.Expressions.Expression<System.Func<TSender, T6>> property6, System.Linq.Expressions.Expression<System.Func<TSender, T7>> property7, System.Linq.Expressions.Expression<System.Func<TSender, T8>> property8, System.Linq.Expressions.Expression<System.Func<TSender, T9>> property9, System.Linq.Expressions.Expression<System.Func<TSender, T10>> property10, System.Linq.Expressions.Expression<System.Func<TSender, T11>> property11, System.Linq.Expressions.Expression<System.Func<TSender, T12>> property12, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TRet> selector, bool isDistinct) { }
        public static System.IObservable<TRet> WhenAnyValue<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, string property1Name, string property2Name, string property3Name, string property4Name, string property5Name, string property6Name, string property7Name, string property8Name, string property9Name, string property10Name, string property11Name, string property12Name, System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TRet> selector, bool isDistinct) { }
    }
    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Evaluates expression-based member chains via reflection; members may be trimmed.")]
    public static class WhenAnyObservableMixin
    {
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs5)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs6)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs7)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs8)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs8, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs9)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs8, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs9, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs10)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs8, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs9, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs10, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs11)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs8, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs9, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs10, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs11, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<TRet>?>> obs12)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Func<T1?, T2?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Func<T1?, T2?, T3?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Func<T1?, T2?, T3?, T4?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4, T5>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T5>?>> obs5, System.Func<T1?, T2?, T3?, T4?, T5?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4, T5, T6>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T5>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T6>?>> obs6, System.Func<T1?, T2?, T3?, T4?, T5?, T6?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4, T5, T6, T7>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T5>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T6>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T7>?>> obs7, System.Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T5>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T6>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T7>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T8>?>> obs8, System.Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T5>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T6>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T7>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T8>?>> obs8, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T9>?>> obs9, System.Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T5>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T6>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T7>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T8>?>> obs8, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T9>?>> obs9, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T10>?>> obs10, System.Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T5>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T6>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T7>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T8>?>> obs8, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T9>?>> obs9, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T10>?>> obs10, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T11>?>> obs11, System.Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, TRet> selector)
            where TSender :  class { }
        public static System.IObservable<TRet> WhenAnyObservable<TSender, TRet, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TSender? sender, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T1>?>> obs1, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T2>?>> obs2, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T3>?>> obs3, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T4>?>> obs4, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T5>?>> obs5, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T6>?>> obs6, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T7>?>> obs7, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T8>?>> obs8, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T9>?>> obs9, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T10>?>> obs10, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T11>?>> obs11, System.Linq.Expressions.Expression<System.Func<TSender, System.IObservable<T12>?>> obs12, System.Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, TRet> selector)
            where TSender :  class { }
    }
}
namespace ReactiveUI.Builder
{
    public static class BuilderMixins
    {
        public static ReactiveUI.Builder.IReactiveUIBuilder BuildApp(this Splat.Builder.IAppBuilder appBuilder) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder ConfigureMessageBus(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder, System.Action<ReactiveUI.MessageBus> configure) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder ConfigureSuspensionDriver(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder, System.Action<ReactiveUI.ISuspensionDriver> configure) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder ConfigureViewLocator(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder, System.Action<ReactiveUI.DefaultViewLocator> configure) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder ForCustomPlatform(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder, System.Reactive.Concurrency.IScheduler mainThreadScheduler, System.Action<Splat.IMutableDependencyResolver> platformServices) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder ForPlatforms(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder, params System.Action<ReactiveUI.Builder.IReactiveUIBuilder>[] platformConfigurations) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder RegisterSingletonView<TView, TViewModel>(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder)
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new ()
            where TViewModel :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.Builder.IReactiveUIBuilder RegisterSingletonViewModel<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)]  TViewModel>(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder)
            where TViewModel :  class, ReactiveUI.IReactiveObject, new () { }
        public static ReactiveUI.Builder.IReactiveUIBuilder RegisterView<TView, TViewModel>(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder)
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new ()
            where TViewModel :  class, ReactiveUI.IReactiveObject { }
        public static ReactiveUI.Builder.IReactiveUIBuilder RegisterViewModel<TViewModel>(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder)
            where TViewModel :  class, ReactiveUI.IReactiveObject, new () { }
        public static ReactiveUI.Builder.IReactiveUIBuilder RegisterViews(this ReactiveUI.Builder.IReactiveUIBuilder builder, System.Action<ReactiveUI.ViewMappingBuilder> configure) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder UsingSplatBuilder(this ReactiveUI.Builder.IReactiveUIBuilder reactiveUIBuilder, System.Action<Splat.Builder.IAppBuilder>? appBuilder) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder UsingSplatModule<T>(this ReactiveUI.Builder.IReactiveUIBuilder builder, T registrationModule)
            where T : Splat.Builder.IModule { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?, T15?> action) { }
        public static ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this ReactiveUI.Builder.IReactiveUIInstance reactiveUIInstance, System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?, T15?, T16?> action) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder WithMainThreadScheduler(this ReactiveUI.Builder.IReactiveUIBuilder builder, System.Reactive.Concurrency.IScheduler scheduler, bool setRxApp = true) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder WithPlatformModule<T>(this ReactiveUI.Builder.IReactiveUIBuilder builder)
            where T : ReactiveUI.IWantsToRegisterStuff, new () { }
        public static ReactiveUI.Builder.IReactiveUIBuilder WithRegistration(this ReactiveUI.Builder.IReactiveUIBuilder builder, System.Action<Splat.IMutableDependencyResolver> configureAction) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder WithRegistrationOnBuild(this ReactiveUI.Builder.IReactiveUIBuilder builder, System.Action<Splat.IMutableDependencyResolver> configureAction) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder WithTaskPoolScheduler(this ReactiveUI.Builder.IReactiveUIBuilder builder, System.Reactive.Concurrency.IScheduler scheduler, bool setRxApp = true) { }
        public static ReactiveUI.Builder.IReactiveUIBuilder WithViewModule<TModule>(this ReactiveUI.Builder.IReactiveUIBuilder builder)
            where TModule : ReactiveUI.IViewModule, new () { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Scans assembly for IViewFor implementations using reflection. For AOT compatibili" +
            "ty, use the ReactiveUIBuilder pattern to RegisterView explicitly.")]
        public static ReactiveUI.Builder.IReactiveUIBuilder WithViewsFromAssembly(this ReactiveUI.Builder.IReactiveUIBuilder builder, System.Reflection.Assembly assembly) { }
    }
    public interface IReactiveUIBuilder : Splat.Builder.IAppBuilder
    {
        ReactiveUI.Builder.IReactiveUIInstance BuildApp();
        ReactiveUI.Builder.IReactiveUIBuilder ConfigureMessageBus(System.Action<ReactiveUI.MessageBus> configure);
        ReactiveUI.Builder.IReactiveUIBuilder ConfigureSuspensionDriver(System.Action<ReactiveUI.ISuspensionDriver> configure);
        ReactiveUI.Builder.IReactiveUIBuilder ConfigureViewLocator(System.Action<ReactiveUI.DefaultViewLocator> configure);
        ReactiveUI.Builder.IReactiveUIBuilder ForCustomPlatform(System.Reactive.Concurrency.IScheduler mainThreadScheduler, System.Action<Splat.IMutableDependencyResolver> platformServices);
        ReactiveUI.Builder.IReactiveUIBuilder ForPlatforms(params System.Action<ReactiveUI.Builder.IReactiveUIBuilder>[] platformConfigurations);
        ReactiveUI.Builder.IReactiveUIBuilder RegisterSingletonView<TView, TViewModel>()
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new ()
            where TViewModel :  class, ReactiveUI.IReactiveObject;
        ReactiveUI.Builder.IReactiveUIBuilder RegisterSingletonViewModel<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)]  TViewModel>()
            where TViewModel :  class, ReactiveUI.IReactiveObject, new ();
        ReactiveUI.Builder.IReactiveUIBuilder RegisterView<TView, TViewModel>()
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new ()
            where TViewModel :  class, ReactiveUI.IReactiveObject;
        ReactiveUI.Builder.IReactiveUIBuilder RegisterViewModel<TViewModel>()
            where TViewModel :  class, ReactiveUI.IReactiveObject, new ();
        ReactiveUI.Builder.IReactiveUIBuilder UsingSplatModule<T>(T registrationModule)
            where T : Splat.Builder.IModule;
        ReactiveUI.Builder.IReactiveUIBuilder WithCacheSizes(int smallCacheLimit, int bigCacheLimit);
        ReactiveUI.Builder.IReactiveUIBuilder WithExceptionHandler(System.IObserver<System.Exception> exceptionHandler);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T>(System.Action<T?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2>(System.Action<T1?, T2?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3>(System.Action<T1?, T2?, T3?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4>(System.Action<T1?, T2?, T3?, T4?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5>(System.Action<T1?, T2?, T3?, T4?, T5?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?, T15?> action);
        ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?, T15?, T16?> action);
        ReactiveUI.Builder.IReactiveUIBuilder WithMainThreadScheduler(System.Reactive.Concurrency.IScheduler scheduler, bool setRxApp = true);
        ReactiveUI.Builder.IReactiveUIBuilder WithPlatformModule<T>()
            where T : ReactiveUI.IWantsToRegisterStuff, new ();
        ReactiveUI.Builder.IReactiveUIBuilder WithPlatformServices();
        ReactiveUI.Builder.IReactiveUIBuilder WithRegistration(System.Action<Splat.IMutableDependencyResolver> configureAction);
        ReactiveUI.Builder.IReactiveUIBuilder WithRegistrationOnBuild(System.Action<Splat.IMutableDependencyResolver> configureAction);
        ReactiveUI.Builder.IReactiveUIBuilder WithSuspensionHost();
        ReactiveUI.Builder.IReactiveUIBuilder WithSuspensionHost<TAppState>();
        ReactiveUI.Builder.IReactiveUIBuilder WithTaskPoolScheduler(System.Reactive.Concurrency.IScheduler scheduler, bool setRxApp = true);
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Scans assembly for IViewFor implementations using reflection. For AOT compatibili" +
            "ty, use the ReactiveUIBuilder pattern to RegisterView explicitly.")]
        ReactiveUI.Builder.IReactiveUIBuilder WithViewsFromAssembly(System.Reflection.Assembly assembly);
    }
    public interface IReactiveUIInstance : Splat.Builder.IAppInstance
    {
        System.Reactive.Concurrency.IScheduler? MainThreadScheduler { get; }
        System.Reactive.Concurrency.IScheduler? TaskpoolScheduler { get; }
    }
    public sealed class ReactiveUIBuilder : Splat.Builder.AppBuilder, ReactiveUI.Builder.IReactiveUIBuilder, ReactiveUI.Builder.IReactiveUIInstance, Splat.Builder.IAppBuilder, Splat.Builder.IAppInstance
    {
        public ReactiveUIBuilder(Splat.IMutableDependencyResolver resolver, Splat.IReadonlyDependencyResolver? current) { }
        public System.Reactive.Concurrency.IScheduler? MainThreadScheduler { get; }
        public System.Reactive.Concurrency.IScheduler? TaskpoolScheduler { get; }
        public ReactiveUI.Builder.IReactiveUIInstance BuildApp() { }
        public ReactiveUI.Builder.IReactiveUIBuilder ConfigureMessageBus(System.Action<ReactiveUI.MessageBus> configure) { }
        public ReactiveUI.Builder.IReactiveUIBuilder ConfigureSuspensionDriver(System.Action<ReactiveUI.ISuspensionDriver> configure) { }
        public ReactiveUI.Builder.IReactiveUIBuilder ConfigureViewLocator(System.Action<ReactiveUI.DefaultViewLocator> configure) { }
        public ReactiveUI.Builder.IReactiveUIBuilder ForCustomPlatform(System.Reactive.Concurrency.IScheduler mainThreadScheduler, System.Action<Splat.IMutableDependencyResolver> platformServices) { }
        public ReactiveUI.Builder.IReactiveUIBuilder ForPlatforms(params System.Action<ReactiveUI.Builder.IReactiveUIBuilder>[] platformConfigurations) { }
        public ReactiveUI.Builder.IReactiveUIBuilder RegisterSingletonView<TView, TViewModel>()
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new ()
            where TViewModel :  class, ReactiveUI.IReactiveObject { }
        public ReactiveUI.Builder.IReactiveUIBuilder RegisterSingletonViewModel<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)]  TViewModel>()
            where TViewModel :  class, ReactiveUI.IReactiveObject, new () { }
        public ReactiveUI.Builder.IReactiveUIBuilder RegisterView<TView, TViewModel>()
            where TView :  class, ReactiveUI.IViewFor<TViewModel>, new ()
            where TViewModel :  class, ReactiveUI.IReactiveObject { }
        public ReactiveUI.Builder.IReactiveUIBuilder RegisterViewModel<TViewModel>()
            where TViewModel :  class, ReactiveUI.IReactiveObject, new () { }
        public ReactiveUI.Builder.IReactiveUIBuilder UsingSplatBuilder(System.Action<Splat.Builder.IAppBuilder> appBuilder) { }
        public ReactiveUI.Builder.IReactiveUIBuilder UsingSplatModule<T>(T registrationModule)
            where T : Splat.Builder.IModule { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithCacheSizes(int smallCacheLimit, int bigCacheLimit) { }
        public override Splat.Builder.IAppBuilder WithCoreServices() { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithExceptionHandler(System.IObserver<System.Exception> exceptionHandler) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T>(System.Action<T?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2>(System.Action<T1?, T2?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3>(System.Action<T1?, T2?, T3?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4>(System.Action<T1?, T2?, T3?, T4?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5>(System.Action<T1?, T2?, T3?, T4?, T5?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?, T15?> action) { }
        public ReactiveUI.Builder.IReactiveUIInstance WithInstance<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(System.Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, T13?, T14?, T15?, T16?> action) { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithMainThreadScheduler(System.Reactive.Concurrency.IScheduler scheduler, bool setRxApp = true) { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithPlatformModule<T>()
            where T : ReactiveUI.IWantsToRegisterStuff, new () { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithPlatformServices() { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithRegistration(ReactiveUI.IWantsToRegisterStuff registration) { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithRegistration(System.Action<Splat.IMutableDependencyResolver> configureAction) { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithRegistrationOnBuild(System.Action<Splat.IMutableDependencyResolver> configureAction) { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithSuspensionHost() { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithSuspensionHost<TAppState>() { }
        public ReactiveUI.Builder.IReactiveUIBuilder WithTaskPoolScheduler(System.Reactive.Concurrency.IScheduler scheduler, bool setRxApp = true) { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Scans assembly for IViewFor implementations using reflection. For AOT compatibili" +
            "ty, use the ReactiveUIBuilder pattern to RegisterView explicitly.")]
        public ReactiveUI.Builder.IReactiveUIBuilder WithViewsFromAssembly(System.Reflection.Assembly assembly) { }
    }
    public static class RxAppBuilder
    {
        public static ReactiveUI.Builder.ReactiveUIBuilder CreateReactiveUIBuilder() { }
        public static ReactiveUI.Builder.ReactiveUIBuilder CreateReactiveUIBuilder(this Splat.IMutableDependencyResolver resolver) { }
        public static void EnsureInitialized() { }
    }
}
namespace ReactiveUI.Interfaces
{
    public interface ISuspensionHost<TAppState> : ReactiveUI.IReactiveObject, ReactiveUI.ISuspensionHost, Splat.IEnableLogger, System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.INotifyPropertyChanging
    {
        TAppState AppStateValue { get; set; }
        System.IObservable<TAppState?> AppStateValueChanged { get; }
        System.Func<TAppState>? CreateNewAppStateTyped { get; set; }
    }
}