<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICSharpCode.NRefactory</name>
    </assembly>
    <members>
        <member name="T:ICSharpCode.NRefactory.Documentation.DocumentationComment">
            <summary>
            Represents a documentation comment.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.DocumentationComment.#ctor(ICSharpCode.NRefactory.Editor.ITextSource,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Creates a new DocumentationComment.
            </summary>
            <param name="xml">The XML text.</param>
            <param name="context">Context for resolving cref attributes.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.DocumentationComment.#ctor(System.String,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Creates a new DocumentationComment.
            </summary>
            <param name="xml">The XML text.</param>
            <param name="context">Context for resolving cref attributes.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.DocumentationComment.ResolveCref(System.String)">
            <summary>
            Resolves the given cref value to an entity.
            Returns null if the entity is not found, or if the cref attribute is syntactically invalid.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Documentation.DocumentationComment.Xml">
            <summary>
            Gets the XML code for this documentation comment.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.GetPotentiallyNestedClassTypeReference">
            <summary>
            A type reference of the form 'Some.Namespace.TopLevelType.NestedType`n'.
            We do not know the boundary between namespace name and top level type, so we have to try
            all possibilities.
            The type parameter count only applies to the innermost type, all outer types must be non-generic.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeReference">
            <summary>
            Represents a reference to a type.
            Must be resolved before it can be used as type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeReference.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves this type reference.
            </summary>
            <param name="context">
            Context to use for resolving this type reference.
            Which kind of context is required depends on the which kind of type reference this is;
            please consult the documentation of the method that was used to create this type reference,
            or that of the class implementing this method.
            </param>
            <returns>
            Returns the resolved type.
            In case of an error, returns an unknown type (<see cref="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Unknown"/>).
            Never returns null.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.IDocumentationProvider">
            <summary>
            Provides XML documentation for entities.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the XML documentation for the specified entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.IUnresolvedDocumentationProvider">
            <summary>
            Provides XML documentation for entities.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IUnresolvedDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity)">
            <summary>
            Gets the XML documentation for the specified entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IUnresolvedDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity,ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the XML documentation for the specified entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.IDocument">
            <summary>
            A document representing a source code file for refactoring.
            Line and column counting starts at 1.
            Offset counting starts at 0.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ITextSource">
            <summary>
            A read-only view on a (potentially mutable) text source.
            The IDocument interface derives from this interface.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.CreateSnapshot">
            <summary>
            Creates an immutable snapshot of this text source.
            Unlike all other methods in this interface, this method is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.CreateSnapshot(System.Int32,System.Int32)">
            <summary>
            Creates an immutable snapshot of a part of this text source.
            Unlike all other methods in this interface, this method is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.CreateReader">
            <summary>
            Creates a new TextReader to read from this text source.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.CreateReader(System.Int32,System.Int32)">
            <summary>
            Creates a new TextReader to read from this text source.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.GetCharAt(System.Int32)">
            <summary>
            Gets a character at the specified position in the document.
            </summary>
            <paramref name="offset">The index of the character to get.</paramref>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset is outside the valid range (0 to TextLength-1).</exception>
            <returns>The character at the specified position.</returns>
            <remarks>This is the same as Text[offset], but is more efficient because
             it doesn't require creating a String object.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.GetText(System.Int32,System.Int32)">
            <summary>
            Retrieves the text for a portion of the document.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or length is outside the valid range.</exception>
            <remarks>This is the same as Text.Substring, but is more efficient because
             it doesn't require creating a String object for the whole document.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.GetText(ICSharpCode.NRefactory.Editor.ISegment)">
            <summary>
            Retrieves the text for a portion of the document.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or length is outside the valid range.</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.WriteTextTo(System.IO.TextWriter)">
            <summary>
            Writes the text from this document into the TextWriter.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.WriteTextTo(System.IO.TextWriter,System.Int32,System.Int32)">
            <summary>
            Writes the text from this document into the TextWriter.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Gets the index of the first occurrence of the character in the specified array.
            </summary>
            <param name="c">Character to search for</param>
            <param name="startIndex">Start index of the area to search.</param>
            <param name="count">Length of the area to search.</param>
            <returns>The first index where the character was found; or -1 if no occurrence was found.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Gets the index of the first occurrence of any character in the specified array.
            </summary>
            <param name="anyOf">Characters to search for</param>
            <param name="startIndex">Start index of the area to search.</param>
            <param name="count">Length of the area to search.</param>
            <returns>The first index where any character was found; or -1 if no occurrence was found.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the index of the first occurrence of the specified search text in this text source.
            </summary>
            <param name="searchText">The search text</param>
            <param name="startIndex">Start index of the area to search.</param>
            <param name="count">Length of the area to search.</param>
            <param name="comparisonType">String comparison to use.</param>
            <returns>The first index where the search term was found; or -1 if no occurrence was found.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.LastIndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Gets the index of the last occurrence of the specified character in this text source.
            </summary>
            <param name="c">The search character</param>
            <param name="startIndex">Start index of the area to search.</param>
            <param name="count">Length of the area to search.</param>
            <returns>The last index where the search term was found; or -1 if no occurrence was found.</returns>
            <remarks>The search proceeds backwards from (startIndex+count) to startIndex.
            This is different than the meaning of the parameters on string.LastIndexOf!</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the index of the last occurrence of the specified search text in this text source.
            </summary>
            <param name="searchText">The search text</param>
            <param name="startIndex">Start index of the area to search.</param>
            <param name="count">Length of the area to search.</param>
            <param name="comparisonType">String comparison to use.</param>
            <returns>The last index where the search term was found; or -1 if no occurrence was found.</returns>
            <remarks>The search proceeds backwards from (startIndex+count) to startIndex.
            This is different than the meaning of the parameters on string.LastIndexOf!</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextSource.Version">
            <summary>
            Gets a version identifier for this text source.
            Returns null for unversioned text sources.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextSource.TextLength">
            <summary>
            Gets the total text length.
            </summary>
            <returns>The length of the text, in characters.</returns>
            <remarks>This is the same as Text.Length, but is more efficient because
             it doesn't require creating a String object.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextSource.Text">
            <summary>
            Gets the whole text as string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.CreateDocumentSnapshot">
            <summary>
            Creates an immutable snapshot of this document.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetLineByNumber(System.Int32)">
            <summary>
            Gets the document line with the specified number.
            </summary>
            <param name="lineNumber">The number of the line to retrieve. The first line has number 1.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetLineByOffset(System.Int32)">
            <summary>
            Gets the document line that contains the specified offset.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetOffset(System.Int32,System.Int32)">
            <summary>
            Gets the offset from a text location.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetLocation(System.Int32)"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets the offset from a text location.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetLocation(System.Int32)"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetLocation(System.Int32)">
            <summary>
            Gets the location from an offset.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Insert(System.Int32,System.String)">
            <summary>
            Inserts text.
            </summary>
            <param name="offset">The offset at which the text is inserted.</param>
            <param name="text">The new text.</param>
            <remarks>
            Anchors positioned exactly at the insertion offset will move according to their movement type.
            For AnchorMovementType.Default, they will move behind the inserted text.
            The caret will also move behind the inserted text.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Insert(System.Int32,ICSharpCode.NRefactory.Editor.ITextSource)">
            <summary>
            Inserts text.
            </summary>
            <param name="offset">The offset at which the text is inserted.</param>
            <param name="text">The new text.</param>
            <remarks>
            Anchors positioned exactly at the insertion offset will move according to their movement type.
            For AnchorMovementType.Default, they will move behind the inserted text.
            The caret will also move behind the inserted text.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Insert(System.Int32,System.String,ICSharpCode.NRefactory.Editor.AnchorMovementType)">
            <summary>
            Inserts text.
            </summary>
            <param name="offset">The offset at which the text is inserted.</param>
            <param name="text">The new text.</param>
            <param name="defaultAnchorMovementType">
            Anchors positioned exactly at the insertion offset will move according to the anchor's movement type.
            For AnchorMovementType.Default, they will move according to the movement type specified by this parameter.
            The caret will also move according to the <paramref name="defaultAnchorMovementType"/> parameter.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Insert(System.Int32,ICSharpCode.NRefactory.Editor.ITextSource,ICSharpCode.NRefactory.Editor.AnchorMovementType)">
            <summary>
            Inserts text.
            </summary>
            <param name="offset">The offset at which the text is inserted.</param>
            <param name="text">The new text.</param>
            <param name="defaultAnchorMovementType">
            Anchors positioned exactly at the insertion offset will move according to the anchor's movement type.
            For AnchorMovementType.Default, they will move according to the movement type specified by this parameter.
            The caret will also move according to the <paramref name="defaultAnchorMovementType"/> parameter.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Remove(System.Int32,System.Int32)">
            <summary>
            Removes text.
            </summary>
            <param name="offset">Starting offset of the text to be removed.</param>
            <param name="length">Length of the text to be removed.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Replace(System.Int32,System.Int32,System.String)">
            <summary>
            Replaces text.
            </summary>
            <param name="offset">The starting offset of the text to be replaced.</param>
            <param name="length">The length of the text to be replaced.</param>
            <param name="newText">The new text.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Replace(System.Int32,System.Int32,ICSharpCode.NRefactory.Editor.ITextSource)">
            <summary>
            Replaces text.
            </summary>
            <param name="offset">The starting offset of the text to be replaced.</param>
            <param name="length">The length of the text to be replaced.</param>
            <param name="newText">The new text.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.StartUndoableAction">
            <summary>
            Make the document combine the following actions into a single
            action for undo purposes.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.EndUndoableAction">
            <summary>
            Ends the undoable action started with <see cref="M:ICSharpCode.NRefactory.Editor.IDocument.StartUndoableAction"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.OpenUndoGroup">
            <summary>
            Creates an undo group. Dispose the returned value to close the undo group.
            </summary>
            <returns>An object that closes the undo group when Dispose() is called.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.CreateAnchor(System.Int32)">
            <summary>
            Creates a new <see cref="T:ICSharpCode.NRefactory.Editor.ITextAnchor"/> at the specified offset.
            </summary>
            <inheritdoc cref="T:ICSharpCode.NRefactory.Editor.ITextAnchor" select="remarks|example"/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocument.Text">
            <summary>
            Gets/Sets the text of the whole document..
            </summary>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.IDocument.TextChanging">
            <summary>
            This event is called directly before a change is applied to the document.
            </summary>
            <remarks>
            It is invalid to modify the document within this event handler.
            Aborting the change (by throwing an exception) is likely to cause corruption of data structures
            that listen to the Changing and Changed events.
            </remarks>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.IDocument.TextChanged">
            <summary>
            This event is called directly after a change is applied to the document.
            </summary>
            <remarks>
            It is invalid to modify the document within this event handler.
            Aborting the event handler (by throwing an exception) is likely to cause corruption of data structures
            that listen to the Changing and Changed events.
            </remarks>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.IDocument.ChangeCompleted">
            <summary>
            This event is called after a group of changes is completed.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.Editor.IDocument.EndUndoableAction"/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocument.LineCount">
            <summary>
            Gets the number of lines in the document.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocument.FileName">
            <summary>
            Gets the name of the file the document is stored in.
            Could also be a non-existent dummy file name or null if no name has been set.
            </summary>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.IDocument.FileNameChanged">
            <summary>
            Fired when the file name of the document changes.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.IDocumentLine">
            <summary>
            A line inside a <see cref="T:ICSharpCode.NRefactory.Editor.IDocument"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ISegment">
            <summary>
            An (Offset,Length)-pair.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ISegment.Offset">
            <summary>
            Gets the start offset of the segment.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ISegment.Length">
            <summary>
            Gets the length of the segment.
            </summary>
            <remarks>For line segments (IDocumentLine), the length does not include the line delimeter.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ISegment.EndOffset">
            <summary>
            Gets the end offset of the segment.
            </summary>
            <remarks>EndOffset = Offset + Length;</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.TotalLength">
            <summary>
            Gets the length of this line, including the line delimiter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.DelimiterLength">
            <summary>
            Gets the length of the line terminator.
            Returns 1 or 2; or 0 at the end of the document.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.LineNumber">
            <summary>
            Gets the number of this line.
            The first line has the number 1.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.PreviousLine">
            <summary>
            Gets the previous line. Returns null if this is the first line in the document.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.NextLine">
            <summary>
            Gets the next line. Returns null if this is the last line in the document.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.IsDeleted">
            <summary>
            Gets whether the line was deleted.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ISegmentExtensions">
            <summary>
            Extension methods for <see cref="T:ICSharpCode.NRefactory.Editor.ISegment"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ISegmentExtensions.Contains(ICSharpCode.NRefactory.Editor.ISegment,System.Int32,System.Int32)">
            <summary>
            Gets whether <paramref name="segment"/> fully contains the specified segment.
            </summary>
            <remarks>
            Use <c>segment.Contains(offset, 0)</c> to detect whether a segment (end inclusive) contains offset;
            use <c>segment.Contains(offset, 1)</c> to detect whether a segment (end exclusive) contains offset.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ISegmentExtensions.Contains(ICSharpCode.NRefactory.Editor.ISegment,ICSharpCode.NRefactory.Editor.ISegment)">
            <summary>
            Gets whether <paramref name="thisSegment"/> fully contains the specified segment.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ITextAnchor">
            <summary>
            The TextAnchor class references an offset (a position between two characters).
            It automatically updates the offset when text is inserted/removed in front of the anchor.
            </summary>
            <remarks>
            <para>Use the <see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Offset"/> property to get the offset from a text anchor.
            Use the <see cref="M:ICSharpCode.NRefactory.Editor.IDocument.CreateAnchor(System.Int32)"/> method to create an anchor from an offset.
            </para>
            <para>
            The document will automatically update all text anchors; and because it uses weak references to do so,
            the garbage collector can simply collect the anchor object when you don't need it anymore.
            </para>
            <para>Moreover, the document is able to efficiently update a large number of anchors without having to look
            at each anchor object individually. Updating the offsets of all anchors usually only takes time logarithmic
            to the number of anchors. Retrieving the <see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Offset"/> property also runs in O(lg N).</para>
            </remarks>
            <example>
            Usage:
            <code>TextAnchor anchor = document.CreateAnchor(offset);
            ChangeMyDocument();
            int newOffset = anchor.Offset;
            </code>
            </example>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Location">
            <summary>
            Gets the text location of this anchor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to get the Offset from a deleted anchor.</exception>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Offset">
            <summary>
            Gets the offset of the text anchor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to get the Offset from a deleted anchor.</exception>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.MovementType">
            <summary>
            Controls how the anchor moves.
            </summary>
            <remarks>Anchor movement is ambiguous if text is inserted exactly at the anchor's location.
            Does the anchor stay before the inserted text, or does it move after it?
            The property <see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.MovementType"/> will be used to determine which of these two options the anchor will choose.
            The default value is <see cref="F:ICSharpCode.NRefactory.Editor.AnchorMovementType.Default"/>.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.SurviveDeletion">
            <summary>
            <para>
            Specifies whether the anchor survives deletion of the text containing it.
            </para><para>
            <c>false</c>: The anchor is deleted when the a selection that includes the anchor is deleted.
            <c>true</c>: The anchor is not deleted.
            </para>
            </summary>
            <remarks><inheritdoc cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.IsDeleted"/></remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.IsDeleted">
            <summary>
            Gets whether the anchor was deleted.
            </summary>
            <remarks>
            <para>When a piece of text containing an anchor is removed, then that anchor will be deleted.
            First, the <see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.IsDeleted"/> property is set to true on all deleted anchors,
            then the <see cref="E:ICSharpCode.NRefactory.Editor.ITextAnchor.Deleted"/> events are raised.
            You cannot retrieve the offset from an anchor that has been deleted.</para>
            <para>This deletion behavior might be useful when using anchors for building a bookmark feature,
            but in other cases you want to still be able to use the anchor. For those cases, set <c><see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.SurviveDeletion"/> = true</c>.</para>
            </remarks>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.ITextAnchor.Deleted">
            <summary>
            Occurs after the anchor was deleted.
            </summary>
            <remarks>
            <inheritdoc cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.IsDeleted"/>
            <para>Due to the 'weak reference' nature of text anchors, you will receive
            the Deleted event only while your code holds a reference to the TextAnchor object.
            </para>
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Line">
            <summary>
            Gets the line number of the anchor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to get the Offset from a deleted anchor.</exception>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Column">
            <summary>
            Gets the column number of this anchor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to get the Offset from a deleted anchor.</exception>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.AnchorMovementType">
            <summary>
            Defines how a text anchor moves.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Editor.AnchorMovementType.Default">
            <summary>
            When text is inserted at the anchor position, the type of the insertion
            determines where the caret moves to. For normal insertions, the anchor will move
            after the inserted text.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Editor.AnchorMovementType.BeforeInsertion">
            <summary>
            Behaves like a start marker - when text is inserted at the anchor position, the anchor will stay
            before the inserted text.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Editor.AnchorMovementType.AfterInsertion">
            <summary>
            Behave like an end marker - when text is insered at the anchor position, the anchor will move
            after the inserted text.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ITextSourceVersion">
            <summary>
            Represents a version identifier for a text source.
            </summary>
            <remarks>
            Verions can be used to efficiently detect whether a document has changed and needs reparsing;
            or even to implement incremental parsers.
            It is a separate class from ITextSource to allow the GC to collect the text source while
            the version checkpoint is still in use.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSourceVersion.BelongsToSameDocumentAs(ICSharpCode.NRefactory.Editor.ITextSourceVersion)">
            <summary>
            Gets whether this checkpoint belongs to the same document as the other checkpoint.
            </summary>
            <remarks>
            Returns false when given <c>null</c>.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSourceVersion.CompareAge(ICSharpCode.NRefactory.Editor.ITextSourceVersion)">
            <summary>
            Compares the age of this checkpoint to the other checkpoint.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <exception cref="T:System.ArgumentException">Raised if 'other' belongs to a different document than this version.</exception>
            <returns>-1 if this version is older than <paramref name="other"/>.
            0 if <c>this</c> version instance represents the same version as <paramref name="other"/>.
            1 if this version is newer than <paramref name="other"/>.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSourceVersion.GetChangesTo(ICSharpCode.NRefactory.Editor.ITextSourceVersion)">
            <summary>
            Gets the changes from this checkpoint to the other checkpoint.
            If 'other' is older than this checkpoint, reverse changes are calculated.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <exception cref="T:System.ArgumentException">Raised if 'other' belongs to a different document than this checkpoint.</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSourceVersion.MoveOffsetTo(ICSharpCode.NRefactory.Editor.ITextSourceVersion,System.Int32,ICSharpCode.NRefactory.Editor.AnchorMovementType)">
            <summary>
            Calculates where the offset has moved in the other buffer version.
            </summary>
            <exception cref="T:System.ArgumentException">Raised if 'other' belongs to a different document than this checkpoint.</exception>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ReadOnlyDocument">
            <summary>
            Read-only implementation of <see cref="T:ICSharpCode.NRefactory.Editor.IDocument"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.#ctor(ICSharpCode.NRefactory.Editor.ITextSource)">
            <summary>
            Creates a new ReadOnlyDocument from the given text source.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.#ctor(System.String)">
            <summary>
            Creates a new ReadOnlyDocument from the given string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.#ctor(ICSharpCode.NRefactory.Editor.ITextSource,System.String)">
            <summary>
            Creates a new ReadOnlyDocument from the given text source;
            and sets IDocument.FileName to the specified file name.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetLineByNumber(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetLineByOffset(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetOffset(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetLocation(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateAnchor(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateSnapshot(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateDocumentSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateReader">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateReader(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.WriteTextTo(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.WriteTextTo(System.IO.TextWriter,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetCharAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetText(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetText(ICSharpCode.NRefactory.Editor.ISegment)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.IndexOf(System.Char,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.LastIndexOf(System.Char,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.Text">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.LineCount">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.Version">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.TextLength">
            <inheritdoc/>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.FileNameChanged">
            <inheritdoc/>
            <remarks>Will never be raised on <see cref="T:ICSharpCode.NRefactory.Editor.ReadOnlyDocument"/>.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.FileName">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.StringBuilderDocument">
            <summary>
            Document based on a string builder.
            This class serves as a reference implementation for the IDocument interface.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.#ctor">
            <summary>
            Creates a new StringBuilderDocument.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.#ctor(System.String)">
            <summary>
            Creates a new StringBuilderDocument with the specified initial text.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.#ctor(ICSharpCode.NRefactory.Editor.ITextSource)">
            <summary>
            Creates a new StringBuilderDocument with the initial text copied from the specified text source.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetLineByNumber(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetLineByOffset(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetOffset(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetLocation(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Insert(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Insert(System.Int32,ICSharpCode.NRefactory.Editor.ITextSource)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Insert(System.Int32,System.String,ICSharpCode.NRefactory.Editor.AnchorMovementType)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Insert(System.Int32,ICSharpCode.NRefactory.Editor.ITextSource,ICSharpCode.NRefactory.Editor.AnchorMovementType)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Remove(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Replace(System.Int32,System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Replace(System.Int32,System.Int32,ICSharpCode.NRefactory.Editor.ITextSource)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.StartUndoableAction">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.EndUndoableAction">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.OpenUndoGroup">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.CreateDocumentSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.CreateSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.CreateSnapshot(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.CreateReader">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.CreateReader(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.WriteTextTo(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.WriteTextTo(System.IO.TextWriter,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetCharAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetText(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetText(ICSharpCode.NRefactory.Editor.ISegment)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.IndexOf(System.Char,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.LastIndexOf(System.Char,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.CreateAnchor(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringBuilderDocument.GetService(System.Type)">
            <inheritdoc/>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.StringBuilderDocument.TextChanging">
            <inheritdoc/>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.StringBuilderDocument.TextChanged">
            <inheritdoc/>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.StringBuilderDocument.ChangeCompleted">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Version">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringBuilderDocument.LineCount">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringBuilderDocument.Text">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringBuilderDocument.TextLength">
            <inheritdoc/>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.StringBuilderDocument.FileNameChanged">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringBuilderDocument.FileName">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.TextChangeEventArgs">
            <summary>
            Describes a change of the document text.
            This class is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Creates a new TextChangeEventArgs object.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.#ctor(System.Int32,ICSharpCode.NRefactory.Editor.ITextSource,ICSharpCode.NRefactory.Editor.ITextSource)">
            <summary>
            Creates a new TextChangeEventArgs object.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.GetNewOffset(System.Int32,ICSharpCode.NRefactory.Editor.AnchorMovementType)">
            <summary>
            Gets the new offset where the specified offset moves after this document change.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.Invert">
            <summary>
            Creates TextChangeEventArgs for the reverse change.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.Offset">
            <summary>
            The offset at which the change occurs.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.RemovedText">
            <summary>
            The text that was removed.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.RemovalLength">
            <summary>
            The number of characters removed.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.InsertedText">
            <summary>
            The text that was inserted.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.InsertionLength">
            <summary>
            The number of characters inserted.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.StringTextSource">
            <summary>
            Implements the ITextSource interface using a string.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Editor.StringTextSource.Empty">
            <summary>
            Gets a text source containing the empty string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.#ctor(System.String)">
            <summary>
            Creates a new StringTextSource with the given text.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.#ctor(System.String,ICSharpCode.NRefactory.Editor.ITextSourceVersion)">
            <summary>
            Creates a new StringTextSource with the given text.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.CreateSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.CreateSnapshot(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.CreateReader">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.CreateReader(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.WriteTextTo(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.WriteTextTo(System.IO.TextWriter,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.GetCharAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.GetText(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.GetText(ICSharpCode.NRefactory.Editor.ISegment)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.IndexOf(System.Char,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.LastIndexOf(System.Char,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringTextSource.Version">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringTextSource.TextLength">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringTextSource.Text">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.TextSourceVersionProvider">
            <summary>
            Provides ITextSourceVersion instances.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.TextSourceVersionProvider.AppendChange(ICSharpCode.NRefactory.Editor.TextChangeEventArgs)">
            <summary>
            Replaces the current version with a new version.
            </summary>
            <param name="change">Change from current version to new version</param>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextSourceVersionProvider.CurrentVersion">
            <summary>
            Gets the current version.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.IAnnotatable">
            <summary>
            Provides an interface to handle annotations in an object.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.Annotation``1">
            <summary>
            Gets the first annotation of the specified type.
            Returns null if no matching annotation exists.
            </summary>
            <typeparam name='T'>
            The type of the annotation.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.Annotation(System.Type)">
            <summary>
            Gets the first annotation of the specified type.
            Returns null if no matching annotation exists.
            </summary>
            <param name='type'>
            The type of the annotation.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.AddAnnotation(System.Object)">
            <summary>
            Adds an annotation to this instance.
            </summary>
            <param name='annotation'>
            The annotation to add.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.RemoveAnnotations``1">
            <summary>
            Removes all annotations of the specified type.
            </summary>
            <typeparam name='T'>
            The type of the annotations to remove.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.RemoveAnnotations(System.Type)">
            <summary>
            Removes all annotations of the specified type.
            </summary>
            <param name='type'>
            The type of the annotations to remove.
            </param>
        </member>
        <member name="P:ICSharpCode.NRefactory.IAnnotatable.Annotations">
            <summary>
            Gets all annotations stored on this IAnnotatable.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.AbstractAnnotatable">
            <summary>
            Base class used to implement the IAnnotatable interface.
            This implementation is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.AbstractAnnotatable.CloneAnnotations">
            <summary>
            Clones all annotations.
            This method is intended to be called by Clone() implementations in derived classes.
            <code>
            AstNode copy = (AstNode)MemberwiseClone();
            copy.CloneAnnotations();
            </code>
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.AbstractAnnotatable.Annotations">
            <summary>
            Gets all annotations stored on this AstNode.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.BacktrackingInfo">
            <summary>
            Container for the backtracking info.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Choice">
            <summary>
            Matches one of several alternatives.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Pattern">
            <summary>
            Base class for all patterns.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.INode">
            <summary>
            AST node that supports pattern matching.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.PatternMatching.Pattern.AnyString">
            <summary>
            Gets the string that matches any string.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.AnyNode">
            <summary>
            Matches any node.
            </summary>
            <remarks>Does not match null nodes.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Backreference">
            <summary>
            Matches the last entry in the specified named group.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.PatternMatching.PatternExtensions.Match(ICSharpCode.NRefactory.PatternMatching.INode,ICSharpCode.NRefactory.PatternMatching.INode)">
            <summary>
            Performs a pattern matching operation.
            <c>this</c> is the pattern, <paramref name="other"/> is the AST that is being matched.
            </summary>
            <returns>
            A match object. Check <see cref="P:ICSharpCode.NRefactory.PatternMatching.Match.Success"/> to see whether the match was successful.
            </returns>
            <remarks>
            Patterns are ASTs that contain special pattern nodes (from the PatternMatching namespace).
            However, it is also possible to match two ASTs without any pattern nodes -
            doing so will produce a successful match if the two ASTs are structurally identical.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Match">
            <summary>
            Represents the result of a pattern matching operation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.NamedNode">
            <summary>
            Represents a named node within a pattern.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Repeat">
            <summary>
            Represents an optional node.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider">
            <summary>
            Provides documentation from an .xml file (as generated by the Microsoft C# compiler).
            </summary>
            <remarks>
            This class first creates an in-memory index of the .xml file, and then uses that to read only the requested members.
            This way, we avoid keeping all the documentation in memory.
            The .xml file is only opened when necessary, the file handle is not kept open all the time.
            If the .xml file is changed, the index will automatically be recreated.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.#ctor(System.String)">
            <summary>
            Creates a new XmlDocumentationProvider.
            </summary>
            <param name="fileName">Name of the .xml file.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.LookupLocalizedXmlDoc(System.String)">
            <summary>
            Given the assembly file name, looks up the XML documentation file name.
            Returns null if no XML documentation file is found.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetHashCode(System.String)">
            <summary>
            Hash algorithm used for the index.
            This is a custom implementation so that old index files work correctly
            even when the .NET string.GetHashCode implementation changes
            (e.g. due to .NET 4.5 hash randomization)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(System.String)">
            <summary>
            Get the documentation for the member with the specified documentation key.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <inheritdoc/>
        </member>
        <member name="F:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.IndexEntry.HashCode">
            <summary>
            Hash code of the documentation tag
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.IndexEntry.PositionInFile">
            <summary>
            Position in the .xml file where the documentation starts
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Role">
            <summary>
            Represents the role a node plays within its parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Role.IsValid(System.Object)">
            <summary>
            Gets whether the specified node is valid in this role.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Role.GetByIndex(System.UInt32)">
            <summary>
            Gets the role with the specified index.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Role`1">
            <summary>
            Represents the role a node plays within its parent.
            All nodes with this role have type T.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Role`1.NullObject">
            <summary>
            Gets the null object used when there's no node with this role.
            Not every role has a null object; this property returns null for roles without a null object.
            </summary>
            <remarks>
            Roles used for non-collections should always have a null object, so that no AST property returns null.
            However, if a role used for collections only, it may leave out the null object.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.AmbiguousTypeResolveResult">
            <summary>
            Represents an ambiguous type resolve result.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.TypeResolveResult">
            <summary>
            The resolved expression refers to a type name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ResolveResult">
            <summary>
            Represents the result of resolving an expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.AmbiguousMemberResolveResult">
            <summary>
            Represents an ambiguous field/property/event access.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.MemberResolveResult">
            <summary>
            Represents the result of a member invocation.
            Used for field/property/event access.
            Also, <see cref="T:ICSharpCode.NRefactory.Semantics.InvocationResolveResult"/> derives from MemberResolveResult.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.MemberResolveResult.Member">
            <summary>
            Gets the member.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.MemberResolveResult.IsVirtualCall">
            <summary>
            Gets whether this MemberResolveResult is a virtual call.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ArrayAccessResolveResult">
            <summary>
            Resolve result representing an array access.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult">
            <summary>
            Resolve result representing an array creation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult.SizeArguments">
            <summary>
            Gets the size arguments.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult.InitializerElements">
            <summary>
            Gets the initializer elements.
            This field may be null if no initializer was specified.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ByReferenceResolveResult">
            <summary>
            Represents the resolve result of an 'ref x' or 'out x' expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ConstantResolveResult">
            <summary>
            ResolveResult representing a compile-time constant.
            Note: this class is mainly used for literals; there may be other ResolveResult classes
            which are compile-time constants as well.
            For example, a reference to a <c>const</c> field results in a <see cref="T:ICSharpCode.NRefactory.Semantics.MemberResolveResult"/>.
            
            Check <see cref="P:ICSharpCode.NRefactory.Semantics.ResolveResult.IsCompileTimeConstant"/> to determine is a resolve result is a constant.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult">
            <summary>
            Represents an implicit or explicit type conversion.
            <c>conversionResolveResult.Input.Type</c> is the source type;
            <c>conversionResolveResult.Type</c> is the target type.
            The <see cref="F:ICSharpCode.NRefactory.Semantics.ConversionResolveResult.Conversion"/> property provides details about the type of conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ConversionResolveResult.CheckForOverflow">
            <summary>
            For numeric conversions, specifies whether overflow checking is enabled.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.SizeOfResolveResult">
            <summary>
            Represents the 'typeof'.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.SizeOfResolveResult.ReferencedType">
            <summary>
            The type referenced by the 'sizeof'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ErrorResolveResult">
            <summary>
            Represents a resolve error.
            
            Note: some errors are represented by other classes; for example a <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult"/> may
            be erroneous if the conversion is invalid.
            </summary>
            <seealso cref="P:ICSharpCode.NRefactory.Semantics.ResolveResult.IsError"/>.
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ErrorResolveResult.UnknownError">
            <summary>
            Gets an ErrorResolveResult instance with <c>Type</c> = <c>SpecialType.UnknownType</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.Conversion">
            <summary>
            Holds information about a conversion between two types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.None">
            <summary>
            Not a valid conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.IdentityConversion">
            <summary>
            Identity conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.ImplicitConstantExpressionConversion">
            <summary>
            The numeric conversion of a constant expression.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.TryCast">
            <summary>
            C# 'as' cast.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsValid">
            <summary>
            Gets whether the conversion is valid.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsTryCast">
            <summary>
            Gets whether the conversion is an '<c>as</c>' cast.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsLifted">
            <summary>
            Gets whether this conversion is a lifted version of another conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsDynamicConversion">
            <summary>
            Gets whether the conversion is dynamic.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsReferenceConversion">
            <summary>
            Gets whether the conversion is a reference conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsEnumerationConversion">
            <summary>
            Gets whether the conversion is an enumeration conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsNullableConversion">
            <summary>
            Gets whether the conversion is a nullable conversion
            (conversion between a nullable type and the regular type).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsUserDefined">
            <summary>
            Gets whether this conversion is user-defined (op_Implicit or op_Explicit).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.ConversionBeforeUserDefinedOperator">
            <summary>
            The conversion that is applied to the input before the user-defined conversion operator is invoked.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.ConversionAfterUserDefinedOperator">
            <summary>
            The conversion that is applied to the result of the user-defined conversion operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsBoxingConversion">
            <summary>
            Gets whether this conversion is a boxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsUnboxingConversion">
            <summary>
            Gets whether this conversion is an unboxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsPointerConversion">
            <summary>
            Gets whether this conversion is a pointer conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsMethodGroupConversion">
            <summary>
            Gets whether this conversion is a method group conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsVirtualMethodLookup">
            <summary>
            For method-group conversions, gets whether to perform a virtual method lookup at runtime.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsAnonymousFunctionConversion">
            <summary>
            Gets whether this conversion is an anonymous function conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.Method">
            <summary>
            Gets the method associated with this conversion.
            For user-defined conversions, this is the method being called.
            For method-group conversions, this is the method that was chosen from the group.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ForEachResolveResult">
            <summary>
            Resolve result representing a 'foreach' loop.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.GetEnumeratorCall">
            <summary>
            Gets the semantic tree for the call to GetEnumerator.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.CollectionType">
            <summary>
            Gets the collection type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.EnumeratorType">
            <summary>
            Gets the enumerator type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.ElementType">
            <summary>
            Gets the element type.
            This is the type that would be inferred for an implicitly-typed element variable.
            For explicitly-typed element variables, this type may differ from <c>ElementVariable.Type</c>.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.ElementVariable">
            <summary>
            Gets the element variable.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.CurrentProperty">
            <summary>
            Gets the Current property on the IEnumerator.
            Returns null if the property is not found.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.MoveNextMethod">
            <summary>
            Gets the MoveNext() method on the IEnumerator.
            Returns null if the method is not found.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.InitializedObjectResolveResult">
            <summary>
            Refers to the object that is currently being initialized.
            Used within <see cref="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.InitializerStatements"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.InvocationResolveResult">
            <summary>
            Represents the result of a method, constructor or indexer invocation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.Arguments">
            <summary>
            Gets the arguments that are being passed to the method, in the order the arguments are being evaluated.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.InitializerStatements">
            <summary>
            Gets the list of initializer statements that are appplied to the result of this invocation.
            This is used to represent object and collection initializers.
            With the initializer statements, the <see cref="T:ICSharpCode.NRefactory.Semantics.InitializedObjectResolveResult"/> is used
            to refer to the result of this invocation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.GetArgumentsForCall">
            <summary>
            Gets the arguments in the order they are being passed to the method.
            For parameter arrays (params), this will return an ArrayCreateResolveResult.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.LocalResolveResult">
            <summary>
            Represents a local variable or parameter.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult">
            <summary>
            Represents a named argument.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult.Member">
            <summary>
            Gets the member to which the parameter belongs.
            This field can be null.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult.Parameter">
            <summary>
            Gets the parameter.
            This field can be null.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult.ParameterName">
            <summary>
            Gets the parameter name.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult.Argument">
            <summary>
            Gets the argument passed to the parameter.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.NamespaceResolveResult">
            <summary>
            Represents that an expression resolved to a namespace.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.OperatorResolveResult">
            <summary>
            Represents a unary/binary/ternary operator invocation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.OperatorType">
            <summary>
            Gets the operator type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.Operands">
            <summary>
            Gets the operands.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.UserDefinedOperatorMethod">
            <summary>
            Gets the user defined operator method.
            Returns null if this is a predefined operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.IsLiftedOperator">
            <summary>
            Gets whether this is a lifted operator.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ThisResolveResult">
            <summary>
            Represents the 'this' reference.
            Also used for the 'base' reference.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.ThisResolveResult.CausesNonVirtualInvocation">
            <summary>
            Gets whether this resolve result causes member invocations to be non-virtual.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.TypeIsResolveResult">
            <summary>
            Resolve result for a C# 'is' expression.
            "Input is TargetType".
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.TypeIsResolveResult.TargetType">
            <summary>
            Type that is being compared with.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.TypeOfResolveResult">
            <summary>
            Represents the 'typeof'.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.TypeOfResolveResult.ReferencedType">
            <summary>
            The type referenced by the 'typeof'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownMemberResolveResult">
            <summary>
            Represents an unknown member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.UnknownMemberResolveResult.TargetType">
            <summary>
            The type on which the method is being called.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownMethodResolveResult">
            <summary>
            Represents an unknown method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownIdentifierResolveResult">
            <summary>
            Represents an unknown identifier.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TextLocation">
            <summary>
            A line/column position.
            Text editor lines/columns are counted started from one.
            </summary>
            <remarks>
            The document provides the methods <see cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetLocation(System.Int32)"/> and
            <see cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)"/> to convert between offsets and TextLocations.
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.MinLine">
            <summary>
            Constant of the minimum line.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.MinColumn">
            <summary>
            Constant of the minimum column.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.Empty">
            <summary>
            Represents no text location (0, 0).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a TextLocation instance.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.ToString">
            <summary>
            Gets a string representation for debugging purposes.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.GetHashCode">
            <summary>
            Gets a hash code.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.Equals(System.Object)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.Equals(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_Equality(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_Inequality(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Inequality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_LessThan(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_GreaterThan(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_LessThanOrEqual(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_GreaterThanOrEqual(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.CompareTo(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.Line">
            <summary>
            Gets the line number.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.Column">
            <summary>
            Gets the column number.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.IsEmpty">
            <summary>
            Gets whether the TextLocation instance is empty.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Accessibility">
            <summary>
            Enum that describes the accessibility of an entity.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.None">
            <summary>
            The entity is completely inaccessible. This is used for C# explicit interface implementations.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Private">
            <summary>
            The entity is only accessible within the same class.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Public">
            <summary>
            The entity is accessible everywhere.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Protected">
            <summary>
            The entity is only accessible within the same class and in derived classes.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Internal">
            <summary>
            The entity is accessible within the same project content.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedOrInternal">
            <summary>
            The entity is accessible both everywhere in the project content, and in all derived classes.
            </summary>
            <remarks>This corresponds to C# 'protected internal'.</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedAndInternal">
            <summary>
            The entity is accessible in derived classes within the same project content.
            </summary>
            <remarks>C# does not support this accessibility.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.Accessibility">
            <summary>
            Gets the accessibility of this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsPrivate">
            <summary>
            Gets a value indicating whether this instance is private.
            </summary>
            <value>
            <c>true</c> if this instance is private; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsPublic">
            <summary>
            Gets a value indicating whether this instance is public.
            </summary>
            <value>
            <c>true</c> if this instance is public; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtected">
            <summary>
            Gets a value indicating whether this instance is protected.
            </summary>
            <value>
            <c>true</c> if this instance is protected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsInternal">
            <summary>
            Gets a value indicating whether this instance is internal.
            </summary>
            <value>
            <c>true</c> if this instance is internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtectedOrInternal">
            <summary>
            Gets a value indicating whether this instance is protected or internal.
            </summary>
            <value>
            <c>true</c> if this instance is protected or internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtectedAndInternal">
            <summary>
            Gets a value indicating whether this instance is protected and internal.
            </summary>
            <value>
            <c>true</c> if this instance is protected and internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.AnonymousType">
            <summary>
            Anonymous type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractType">
            <summary>
            Default implementation for IType interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IType">
            <summary>
            This interface represents a resolved type in the type system.
            </summary>
            <remarks>
            <para>
            A type is potentially
            - a type definition (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/>, i.e. a class, struct, interface, delegate, or built-in primitive type)
            - a parameterized type (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/>, e.g. List&lt;int&gt;)
            - a type parameter (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter"/>, e.g. T)
            - an array (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ArrayType"/>)
            - a pointer (<see cref="T:ICSharpCode.NRefactory.TypeSystem.PointerType"/>)
            - a managed reference (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ByReferenceType"/>)
            - one of the special types (<see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>, <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.NullType"/>,
                 <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.Dynamic"/>, <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnboundTypeArgument"/>)
            
            The <see cref="P:ICSharpCode.NRefactory.TypeSystem.IType.Kind"/> property can be used to switch on the kind of a type.
            </para>
            <para>
            IType uses the null object pattern: <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/> serves as the null object.
            Methods or properties returning IType never return null unless documented otherwise.
            </para>
            <para>
            Types should be compared for equality using the <see cref="M:System.IEquatable`1.Equals(`0)"/> method.
            Identical types do not necessarily use the same object reference.
            </para>
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.FullName">
            <summary>
            Gets the fully qualified name of the class the return type is pointing to.
            </summary>
            <returns>
            "System.Int32[]" for int[]<br/>
            "System.Collections.Generic.List" for List&lt;string&gt;
            "System.Environment.SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.Name">
            <summary>
            Gets the short name of the class the return type is pointing to.
            </summary>
            <returns>
            "Int32[]" for int[]<br/>
            "List" for List&lt;string&gt;
            "SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.ReflectionName">
            <summary>
            Gets the full reflection name of the element.
            </summary>
            <remarks>
            For types, the reflection name can be parsed back into a ITypeReference by using
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)"/>.
            </remarks>
            <returns>
            "System.Int32[]" for int[]<br/>
            "System.Int32[][,]" for C# int[,][]<br/>
            "System.Collections.Generic.List`1[[System.String]]" for List&lt;string&gt;
            "System.Environment+SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.Namespace">
            <summary>
            Gets the full name of the namespace containing this entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetDefinition">
            <summary>
            Gets the underlying type definition.
            Can return null for types which do not have a type definition (for example arrays, pointers, type parameters).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.AcceptVisitor(ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
            <summary>
            Calls ITypeVisitor.Visit for this type.
            </summary>
            <returns>The return value of the ITypeVisitor.Visit call</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.VisitChildren(ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
            <summary>
            Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based
            on the return values of the visit calls.
            </summary>
            <returns>A copy of this type, with all children replaced by the return value of the corresponding visitor call.
            If the visitor returned the original types for all children (or if there are no children), returns <c>this</c>.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.ToTypeReference">
            <summary>
            Creates a type reference that can be used to look up a type equivalent to this type in another compilation.
            </summary>
            <remarks>
            If this type contains open generics, the resulting type reference will need to be looked up in an appropriate generic context.
            Otherwise, the main resolve context of a compilation is sufficient.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetSubstitution">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type.
            Returns TypeParameterSubstitution.Identity if the type is not parametrized.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetSubstitution(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type,
            and also substitutes method type parameters with the specified method type arguments.
            Returns TypeParameterSubstitution.Identity if the type is not parametrized.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets inner classes (including inherited inner classes).
            </summary>
            <param name="filter">The filter used to select which types to return.
            The filter is tested on the original type definitions (before parameterization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            If the nested type is generic, this method will return a parameterized type,
            where the additional type parameters are set to <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnboundTypeArgument"/>.
            </para>
            <para>
            Type parameters belonging to the outer class will have the value copied from the outer type
            if it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,
            and thus 'leaked' to the caller in the same way the GetMembers() method does not specialize members
            from an <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> and 'leaks' type parameters in member signatures.
            </para>
            </remarks>
            <example>
            <code>
            class Base&lt;T&gt; {
            	class Nested&lt;X&gt; {}
            }
            class Derived&lt;A, B&gt; : Base&lt;B&gt; {}
            
            Derived[string,int].GetNestedTypes() = { Base`1+Nested`1[int, unbound] }
            Derived.GetNestedTypes() = { Base`1+Nested`1[`1, unbound] }
            Base[`1].GetNestedTypes() = { Base`1+Nested`1[`1, unbound] }
            Base.GetNestedTypes() = { Base`1+Nested`1[`0, unbound] }
            </code>
            </example>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets inner classes (including inherited inner classes)
            that have <c>typeArguments.Count</c> additional type parameters.
            </summary>
            <param name="typeArguments">The type arguments passed to the inner class</param>
            <param name="filter">The filter used to select which types to return.
            The filter is tested on the original type definitions (before parameterization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            Type parameters belonging to the outer class will have the value copied from the outer type
            if it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,
            and thus 'leaked' to the caller in the same way the GetMembers() method does not specialize members
            from an <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> and 'leaks' type parameters in member signatures.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetConstructors(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all instance constructors for this type.
            </summary>
            <param name="filter">The filter used to select which constructors to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>The result does not include static constructors.
            Constructors in base classes are not returned by default, as GetMemberOptions.IgnoreInheritedMembers is the default value.</para>
            <para>
            For methods on parameterized types, type substitution will be performed on the method signature,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod"/> will be returned.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all methods that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which methods to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            The result does not include constructors or accessors.
            </para>
            <para>
            For methods on parameterized types, type substitution will be performed on the method signature,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod"/> will be returned.
            </para>
            <para>
            If the method being returned is generic, and this type is a parameterized type where the type
            arguments involve another method's type parameters, the resulting specialized signature
            will be ambiguous as to which method a type parameter belongs to.
            For example, "List[[``0]].GetMethods()" will return "ConvertAll(Converter`2[[``0, ``0]])".
            
            If possible, use the other GetMethods() overload to supply type arguments to the method,
            so that both class and method type parameter can be substituted at the same time, so that
            the ambiguity can be avoided.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMethods(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all generic methods that can be called on this type with the specified type arguments.
            </summary>
            <param name="typeArguments">The type arguments used for the method call.</param>
            <param name="filter">The filter used to select which methods to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>The result does not include constructors or accessors.</para>
            <para>
            Type substitution will be performed on the method signature, creating a <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod"/>
            with the specified type arguments.
            </para>
            <para>
            When the list of type arguments is empty, this method acts like the GetMethods() overload without
            the type arguments parameter - that is, it also returns generic methods,
            and the other overload's remarks about ambiguous signatures apply here as well.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetProperties(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedProperty},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all properties that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which properties to return.
            The filter is tested on the original property definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For properties on parameterized types, type substitution will be performed on the property signature,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetFields(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedField},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all fields that can be accessed on this type.
            </summary>
            <param name="filter">The filter used to select which constructors to return.
            The filter is tested on the original field definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For fields on parameterized types, type substitution will be performed on the field's return type,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedField"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetEvents(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedEvent},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all events that can be accessed on this type.
            </summary>
            <param name="filter">The filter used to select which events to return.
            The filter is tested on the original event definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For fields on parameterized types, type substitution will be performed on the event's return type,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedEvent"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMembers(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all members that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which members to return.
            The filter is tested on the original member definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            The resulting list is the union of GetFields(), GetProperties(), GetMethods() and GetEvents().
            It does not include constructors.
            For parameterized types, type substitution will be performed.
            </para>
            <para>
            For generic methods, the remarks about ambiguous signatures from the
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)"/> method apply here as well.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetAccessors(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all accessors belonging to properties or events on this type.
            </summary>
            <param name="filter">The filter used to select which members to return.
            The filter is tested on the original member definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            Accessors are not returned by GetMembers() or GetMethods().
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.Kind">
            <summary>
            Gets the type kind.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.IsReferenceType">
            <summary>
            Gets whether the type is a reference type or value type.
            </summary>
            <returns>
            true, if the type is a reference type.
            false, if the type is a value type.
            null, if the type is not known (e.g. unconstrained generic type parameter or type not found)
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.DeclaringType">
            <summary>
            Gets the parent type, if this is a nested type.
            Returns null for top-level types.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.TypeParameterCount">
            <summary>
            Gets the number of type parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.TypeArguments">
            <summary>
            Gets the type arguments passed to this type.
            If this type is a generic type definition that is not parameterized, this property returns the type parameters,
            as if the type was parameterized with its own type arguments (<c>class C&lt;T&gt; { C&lt;T&gt; field; }</c>).
            
            NOTE: The type will change to IReadOnlyList&lt;IType&gt; in future versions.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.IsParameterized">
            <summary>
            If true the type represents an instance of a generic type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.DirectBaseTypes">
            <summary>
            Gets the direct base types.
            </summary>
            <returns>Returns the direct base types including interfaces</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractResolvedMember">
            <summary>
            Implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMember"/> that resolves an unresolved member.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractResolvedEntity">
            <summary>
            Implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IEntity"/> that resolves an unresolved entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IEntity">
            <summary>
            Represents a resolved entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilationProvider.Compilation">
            <summary>
            Gets the parent compilation.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.EntityType">
            <summary>
            Gets the entity type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Region">
            <summary>
            Gets the complete entity region (including header+body)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.BodyRegion">
            <summary>
            Gets the entity body region.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringTypeDefinition">
            <summary>
            Gets the declaring class.
            For members, this is the class that contains the member.
            For nested classes, this is the outer class. For top-level entities, this property returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringType">
            <summary>
            Gets/Sets the declaring type (incl. type arguments, if any).
            This property never returns null -- for top-level entities, it returns SharedTypes.UnknownType.
            If this is not a specialized member, the value returned is equal to <see cref="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringTypeDefinition"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.ParentAssembly">
            <summary>
            The assembly in which this entity is defined.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Attributes">
            <summary>
            Gets the attributes on this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Documentation">
            <summary>
            Gets the documentation for this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsStatic">
            <summary>
            Gets whether this entity is static.
            Returns true if either the 'static' or the 'const' modifier is set.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsAbstract">
            <summary>
            Returns whether this entity is abstract.
            </summary>
            <remarks>Static classes also count as abstract classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsSealed">
            <summary>
            Returns whether this entity is sealed.
            </summary>
            <remarks>Static classes also count as sealed classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsShadowing">
            <summary>
            Gets whether this member is declared to be shadowing another member with the same name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsSynthetic">
            <summary>
            Gets whether this member is generated by a macro/compiler feature.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IMember">
            <summary>
            Method/field/property/event.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IMember.ToMemberReference">
            <summary>
            Creates a member reference that can be used to rediscover this member in another compilation.
            </summary>
            <remarks>
            If this member is specialized using open generic types, the resulting member reference will need to be looked up in an appropriate generic context.
            Otherwise, the main resolve context of a compilation is sufficient.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IMember.Specialize(ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Specializes this member with the given substitution.
            If this member is already specialized, the new substitution is composed with the existing substition.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.MemberDefinition">
            <summary>
            Gets the original member definition for this member.
            Returns <c>this</c> if this is not a specialized member.
            Specialized members are the result of overload resolution with type substitution.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.UnresolvedMember">
            <summary>
            Gets the unresolved member instance from which this member was created.
            This property may return <c>null</c> for special members that do not have a corresponding unresolved member instance.
            </summary>
            <remarks>
            For specialized members, this property returns the unresolved member for the original member definition.
            For partial methods, this property returns the implementing partial method declaration, if one exists, and the
            defining partial method declaration otherwise.
            For the members used to represent the built-in C# operators like "operator +(int, int);", this property returns <c>null</c>.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.ReturnType">
            <summary>
            Gets the return type of this member.
            This property never returns <c>null</c>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.ImplementedInterfaceMembers">
            <summary>
            Gets the interface members implemented by this member (both implicitly and explicitly).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsExplicitInterfaceImplementation">
            <summary>
            Gets whether this member is explicitly implementing an interface.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsVirtual">
            <summary>
            Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
            members can be overridden, too; if they are abstract or overriding a method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsOverride">
            <summary>
            Gets whether this member is overriding another member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsOverridable">
            <summary>
            Gets if the member can be overridden. Returns true when the member is "abstract", "virtual" or "override" but not "sealed".
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.Substitution">
            <summary>
            Gets the substitution belonging to this specialized member.
            Returns TypeParameterSubstitution.Identity for not specialized members.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IProperty">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IParameterizedMember">
            <summary>
            Represents a method or property.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedMethod">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/> that resolves an unresolved method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IMethod">
            <summary>
            Represents a method, constructor, destructor or operator.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IMethod.Specialize(ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Specializes this method with the given substitution.
            If this method is already specialized, the new substitution is composed with the existing substition.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.Parts">
            <summary>
            Gets the unresolved method parts.
            For partial methods, this returns all parts.
            Otherwise, this returns an array with a single element (new[] { UnresolvedMember }).
            NOTE: The type will change to IReadOnlyList&lt;IUnresolvedMethod&gt; in future versions.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.ReturnTypeAttributes">
            <summary>
            Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
            NOTE: The type will change to IReadOnlyList&lt;IAttribute&gt; in future versions.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.TypeParameters">
            <summary>
            Gets the type parameters of this method; or an empty list if the method is not generic.
            NOTE: The type will change to IReadOnlyList&lt;ITypeParameter&gt; in future versions.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.IsParameterized">
            <summary>
            Gets whether this is a generic method that has been parameterized.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.TypeArguments">
            <summary>
            Gets the type arguments passed to this method.
            If the method is generic but not parameterized yet, this property returns the type parameters,
            as if the method was parameterized with its own type arguments (<c>void M&lt;T&gt;() { M&lt;T&gt;(); }</c>).
            
            NOTE: The type will change to IReadOnlyList&lt;IType&gt; in future versions.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.IsPartial">
            <summary>
            Gets whether the method is a C#-style partial method.
            A call to such a method is ignored by the compiler if the partial method has no body.
            </summary>
            <seealso cref="P:ICSharpCode.NRefactory.TypeSystem.IMethod.HasBody"/>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.IsAsync">
            <summary>
            Gets whether the method is a C#-style async method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.HasBody">
            <summary>
            Gets whether the method has a body.
            This property returns <c>false</c> for <c>abstract</c> or <c>extern</c> methods,
            or for <c>partial</c> methods without implementation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.IsAccessor">
            <summary>
            Gets whether the method is a property/event accessor.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.AccessorOwner">
            <summary>
            If this method is an accessor, returns the corresponding property/event.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.ReducedFrom">
            <summary>
            If this method is reduced from an extension method return the original method, <c>null</c> otherwise.
            A reduced method doesn't contain the extension method parameter. That means that has one parameter less than it's definition.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedMethod.GetDummyConstructor(ICSharpCode.NRefactory.TypeSystem.ICompilation)">
            <summary>
            Gets a dummy constructor for the specified compilation.
            </summary>
            <returns>
            A public instance constructor with IsSynthetic=true and no declaring type.
            </returns>
            <seealso cref="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod.DummyConstructor"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedMethod.GetDummyConstructor(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets a dummy constructor for the specified type.
            </summary>
            <returns>
            A public instance constructor with IsSynthetic=true and the specified declaring type.
            </returns>
            <seealso cref="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod.DummyConstructor"/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.AnonymousTypeReference">
            <summary>
            Anonymous type reference.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ArrayType">
            <summary>
            Represents an array type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning">
            <summary>
            Interface for TypeSystem objects that support interning.
            See <see cref="T:ICSharpCode.NRefactory.TypeSystem.InterningProvider"/> for more information.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.GetHashCodeForInterning">
            <summary>
            Gets a hash code for interning.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.EqualsForInterning(ICSharpCode.NRefactory.TypeSystem.ISupportsInterning)">
            <summary>
            Equality test for interning.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.CecilLoader">
            <summary>
            Allows loading an IProjectContent from an already compiled assembly.
            </summary>
            <remarks>Instance methods are not thread-safe; you need to create multiple instances of CecilLoader
            if you want to load multiple project contents in parallel.</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.CecilLoader.cecilLoaderVersion">
            <summary>
            Version number of the cecil loader.
            Should be incremented when fixing bugs in the cecil loader so that project contents cached on disk
            (which might be incorrect due to the bug) are re-created.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.CecilLoader"/> class.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.CecilLoader"/> class.
            </summary>
            <param name="createCecilReferences">
            If true references to the cecil objects are hold. In this case the cecil loader can do a type system -&gt; cecil mapping.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.#ctor(ICSharpCode.NRefactory.TypeSystem.CecilLoader)">
            <summary>
            Creates a nested CecilLoader for lazy-loading.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadAssembly(Mono.Cecil.AssemblyDefinition)">
            <summary>
            Loads the assembly definition into a project content.
            </summary>
            <returns>Unresolved type system representing the assembly</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadModule(Mono.Cecil.ModuleDefinition)">
            <summary>
            Loads the module definition into a project content.
            </summary>
            <returns>Unresolved type system representing the assembly</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.SetCurrentModule(Mono.Cecil.ModuleDefinition)">
            <summary>
            Sets the current module.
            This causes ReadTypeReference() to use <see cref="F:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAssemblyReference.CurrentAssembly"/> for references
            in that module.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadType(Mono.Cecil.TypeDefinition)">
            <summary>
            Loads a type from Cecil.
            </summary>
            <param name="typeDefinition">The Cecil TypeDefinition.</param>
            <returns>ITypeDefinition representing the Cecil type.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.ReadTypeReference(Mono.Cecil.TypeReference,Mono.Cecil.ICustomAttributeProvider)">
            <summary>
            Reads a type reference.
            </summary>
            <param name="type">The Cecil type reference that should be converted into
            a type system type reference.</param>
            <param name="typeAttributes">Attributes associated with the Cecil type reference.
            This is used to support the 'dynamic' type.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.ReadSecurityDeclaration(Mono.Cecil.SecurityDeclaration)">
            <summary>
            Reads a security declaration.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.IncludeInternalMembers">
            <summary>
            Specifies whether to include internal members. The default is false.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LazyLoad">
            <summary>
            Specifies whether to use lazy loading. The default is false.
            If this property is set to true, the CecilLoader will not copy all the relevant information
            out of the Cecil object model, but will maintain references to the Cecil objects.
            This speeds up the loading process and avoids loading unnecessary information, but it causes
            the Cecil objects to stay in memory (which can significantly increase memory usage).
            It also prevents serialization of the Cecil-loaded type system.
            </summary>
            <remarks>
            Because the type system can be used on multiple threads, but Cecil is not
            thread-safe for concurrent read access, the CecilLoader will lock on the <see cref="T:Mono.Cecil.ModuleDefinition"/> instance
            for every delay-loading operation.
            If you access the Cecil objects directly in your application, you may need to take the same lock.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.DocumentationProvider">
            <summary>
            Gets/Sets the documentation provider that is used to retrieve the XML documentation for all members.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.InterningProvider">
            <summary>
            Gets/Sets the interning provider.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.CancellationToken">
            <summary>
            Gets/Sets the cancellation token used by the cecil loader.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.OnEntityLoaded">
            <summary>
            This delegate gets executed whenever an entity was loaded.
            </summary>
            <remarks>
            This callback may be to build a dictionary that maps between
            entities and cecil objects.
            Warning: if delay-loading is used and the type system is accessed by multiple threads,
            the callback may be invoked concurrently on multiple threads.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.HasCecilReferences">
            <summary>
            Gets a value indicating whether this instance stores references to the cecil objects.
            </summary>
            <value>
            <c>true</c> if this instance has references to the cecil objects; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly">
            <summary>
            Default implementation for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly">
            <summary>
            Represents an unresolved assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAssemblyReference.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves this assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.AssemblyName">
            <summary>
            Gets the assembly name (short name).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.FullAssemblyName">
            <summary>
            Gets the full assembly name (including public key token etc.)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.Location">
            <summary>
            Gets the path to the assembly location. 
            For projects it is the same as the output path.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.AssemblyAttributes">
            <summary>
            Gets the list of all assembly attributes in the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.ModuleAttributes">
            <summary>
            Gets the list of all module attributes in the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.TopLevelTypeDefinitions">
            <summary>
            Gets all non-nested types in the assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.#ctor(System.String)">
            <summary>
            Creates a new unresolved assembly.
            </summary>
            <param name="assemblyName">Full assembly name</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.AddTypeDefinition(ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition)">
            <summary>
            Adds a new top-level type definition to this assembly.
            </summary>
            <remarks>DefaultUnresolvedAssembly does not support partial classes.
            Adding more than one part of a type will cause an ArgumentException.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.AddTypeForwarder(ICSharpCode.NRefactory.TypeSystem.TopLevelTypeName,ICSharpCode.NRefactory.TypeSystem.ITypeReference)">
            <summary>
            Adds a type forwarder.
            This adds both an assembly attribute and an internal forwarder entry, which will be used
            by the resolved assembly to provide the forwarded types.
            </summary>
            <param name="typeName">The name of the type.</param>
            <param name="referencedType">The reference used to look up the type in the target assembly.</param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.AssemblyName">
            <summary>
            Gets/Sets the short assembly name.
            </summary>
            <remarks>
            This class handles the short and the full name independently;
            if you change the short name, you should also change the full name.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.FullAssemblyName">
            <summary>
            Gets/Sets the full assembly name.
            </summary>
            <remarks>
            This class handles the short and the full name independently;
            if you change the full name, you should also change the short name.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IConstantValue">
            <summary>
            Represents an unresolved constant value.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IConstantValue.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the value of this constant.
            </summary>
            <param name="context">Context where the constant value will be used.</param>
            <returns>Resolve result representing the constant value.
            This method never returns null; in case of errors, an ErrorResolveResult will be returned.</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IAssembly">
            <summary>
            Represents an assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAssembly.InternalsVisibleTo(ICSharpCode.NRefactory.TypeSystem.IAssembly)">
            <summary>
            Gets whether the internals of this assembly are visible in the specified assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAssembly.GetTypeDefinition(ICSharpCode.NRefactory.TypeSystem.TopLevelTypeName)">
            <summary>
            Gets the type definition for a top-level type.
            </summary>
            <remarks>This method uses ordinal name comparison, not the compilation's name comparer.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.UnresolvedAssembly">
            <summary>
            Gets the original unresolved assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.IsMainAssembly">
            <summary>
            Gets whether this assembly is the main assembly of the compilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.AssemblyName">
            <summary>
            Gets the assembly name (short name).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.FullAssemblyName">
            <summary>
            Gets the full assembly name (including public key token etc.)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.AssemblyAttributes">
            <summary>
            Gets the list of all assembly attributes in the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.ModuleAttributes">
            <summary>
            Gets the list of all module attributes in the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.RootNamespace">
            <summary>
            Gets the root namespace for this assembly.
            </summary>
            <remarks>
            This always is the namespace without a name - it's unrelated to the 'root namespace' project setting.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.TopLevelTypeDefinitions">
            <summary>
            Gets all non-nested types in the assembly.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.INamespace">
            <summary>
            Represents a resolved namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.INamespace.GetChildNamespace(System.String)">
            <summary>
            Gets a direct child namespace by its short name.
            Returns null when the namespace cannot be found.
            </summary>
            <remarks>
            This method uses the compilation's current string comparer.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.INamespace.GetTypeDefinition(System.String,System.Int32)">
            <summary>
            Gets the type with the specified short name and type parameter count.
            Returns null if the type cannot be found.
            </summary>
            <remarks>
            This method uses the compilation's current string comparer.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.ExternAlias">
            <summary>
            Gets the extern alias for this namespace.
            Returns an empty string for normal namespaces.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.FullName">
            <summary>
            Gets the full name of this namespace. (e.g. "System.Collections")
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.Name">
            <summary>
            Gets the short name of this namespace (e.g. "Collections").
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.ParentNamespace">
            <summary>
            Gets the parent namespace.
            Returns null if this is the root namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.ChildNamespaces">
            <summary>
            Gets the child namespaces in this namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.Types">
            <summary>
            Gets the types in this namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.ContributingAssemblies">
            <summary>
            Gets the assemblies that contribute types to this namespace (or to child namespaces).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute">
            <summary>
            Represents an unresolved attribute.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute.CreateResolvedAttribute(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute.Region">
            <summary>
            Gets the code region of this attribute.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IAttribute">
            <summary>
            Represents an attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.Region">
            <summary>
            Gets the code region of this attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.AttributeType">
            <summary>
            Gets the type of the attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.Constructor">
            <summary>
            Gets the constructor being used.
            This property may return null if no matching constructor was found.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.PositionalArguments">
            <summary>
            Gets the positional arguments.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.NamedArguments">
            <summary>
            Gets the named arguments passed to the attribute.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedEntity">
            <summary>
            Base class for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity"/> implementations.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity">
            <summary>
            Represents an unresolved entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.EntityType">
            <summary>
            Gets the entity type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.Region">
            <summary>
            Gets the complete entity region (including header+body)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.BodyRegion">
            <summary>
            Gets the entity body region.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.DeclaringTypeDefinition">
            <summary>
            Gets the declaring class.
            For members, this is the class that contains the member.
            For nested classes, this is the outer class. For top-level entities, this property returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.UnresolvedFile">
            <summary>
            Gets the parsed file in which this entity is defined.
            Returns null if this entity wasn't parsed from source code (e.g. loaded from a .dll with CecilLoader).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.Attributes">
            <summary>
            Gets the attributes on this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsStatic">
            <summary>
            Gets whether this entity is static.
            Returns true if either the 'static' or the 'const' modifier is set.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsAbstract">
            <summary>
            Returns whether this entity is abstract.
            </summary>
            <remarks>Static classes also count as abstract classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsSealed">
            <summary>
            Returns whether this entity is sealed.
            </summary>
            <remarks>Static classes also count as sealed classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsShadowing">
            <summary>
            Gets whether this member is declared to be shadowing another member with the same name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsSynthetic">
            <summary>
            Gets whether this member is generated by a macro/compiler feature.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedEntity.ApplyInterningProvider(ICSharpCode.NRefactory.TypeSystem.InterningProvider)">
            <summary>
            Uses the specified interning provider to intern
            strings and lists in this entity.
            This method does not test arbitrary objects to see if they implement ISupportsInterning;
            instead we assume that those are interned immediately when they are created (before they are added to this entity).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedEntity.Clone">
            <summary>
            Creates a shallow clone of this entity.
            Collections (e.g. a type's member list) will be cloned as well, but the elements
            of said list will not be.
            If this instance is frozen, the clone will be unfrozen.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition">
            <summary>
            Represents an unresolved class, enum, interface, struct, delegate or VB module.
            For partial classes, an unresolved type definition represents only a single part.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Looks up the resolved type definition from the <paramref name="context"/> corresponding to this unresolved
            type definition.
            </summary>
            <param name="context">
            Context for looking up the type. The context must specify the current assembly.
            A <see cref="T:ICSharpCode.NRefactory.TypeSystem.SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
            </param>
            <returns>
            Returns the resolved type definition.
            In case of an error, returns an <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType"/> instance.
            Never returns null.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition.CreateResolveContext(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            This method is used to add language-specific elements like the C# UsingScope
            to the type resolve context.
            </summary>
            <param name="parentContext">The parent context (e.g. the parent assembly),
            including the parent type definition for inner classes.</param>
            <returns>
            The parent context, modified to include language-specific elements (e.g. using scope)
            associated with this type definition.
            </returns>
            <remarks>
            Use <c>unresolvedTypeDef.CreateResolveContext(parentContext).WithTypeDefinition(typeDef)</c> to
            create the context for use within the type definition.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition.HasExtensionMethods">
            <summary>
            Gets whether the type definition contains extension methods.
            Returns null when the type definition needs to be resolved in order to determine whether
            methods are extension methods.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition.AddDefaultConstructorIfRequired">
            <summary>
            Gets whether this unresolved type definition causes the addition of a default constructor
            if no other constructor is present.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ComHelper">
            <summary>
            Helper methods for COM.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ComHelper.IsComImport(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Gets whether the specified type is imported from COM.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ComHelper.GetCoClass(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Gets the CoClass of the specified COM interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.DefaultSolutionSnapshot">
            <summary>
            Default implementation of ISolutionSnapshot.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot">
            <summary>
            Represents a snapshot of the whole solution (multiple compilations).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot.GetProjectContent(System.String)">
            <summary>
            Gets the project content with the specified file name.
            Returns null if no such project exists in the solution.
            </summary>
            <remarks>
            This method is used by the <see cref="T:ICSharpCode.NRefactory.TypeSystem.ProjectReference"/> class.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot.GetCompilation(ICSharpCode.NRefactory.TypeSystem.IProjectContent)">
            <summary>
            Gets the compilation for the specified project.
            The project must be a part of the solution (passed to the solution snapshot's constructor).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DefaultSolutionSnapshot.#ctor(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IProjectContent})">
            <summary>
            Creates a new DefaultSolutionSnapshot with the specified projects.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DefaultSolutionSnapshot.#ctor">
            <summary>
            Creates a new DefaultSolutionSnapshot that does not support <see cref="T:ICSharpCode.NRefactory.TypeSystem.ProjectReference"/>s.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DomRegion.IsInside(System.Int32,System.Int32)">
            <remarks>
            Returns true, if the given coordinates (line, column) are in the region.
            This method assumes that for an unknown end the end line is == -1
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndLine">
            <value>
            if the end line is == -1 the end column is -1 too
            this stands for an unknwon end
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndColumn">
            <value>
            if the end column is == -1 the end line is -1 too
            this stands for an unknown end
            </value>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution">
            <summary>
            Substitutes class and method type parameters.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeVisitor">
            <summary>
            Base class for the visitor pattern on <see cref="T:ICSharpCode.NRefactory.TypeSystem.IType"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution.Identity">
            <summary>
            The identity function.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution.#ctor(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
            <summary>
            Creates a new type parameter substitution.
            </summary>
            <param name="classTypeArguments">
            The type arguments to substitute for class type parameters.
            Pass <c>null</c> to keep class type parameters unmodified.
            </param>
            <param name="methodTypeArguments">
            The type arguments to substitute for method type parameters.
            Pass <c>null</c> to keep method type parameters unmodified.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution.Compose(ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution,ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Computes a single TypeParameterSubstitution so that for all types <c>t</c>:
            <c>t.AcceptVisitor(Compose(g, f)) equals t.AcceptVisitor(f).AcceptVisitor(g)</c>
            </summary>
            <remarks>If you consider type parameter substitution to be a function, this is function composition.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution.ClassTypeArguments">
            <summary>
            Gets the list of class type arguments.
            Returns <c>null</c> if this substitution keeps class type parameters unmodified.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution.MethodTypeArguments">
            <summary>
            Gets the list of method type arguments.
            Returns <c>null</c> if this substitution keeps method type parameters unmodified.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions">
            <summary>
            Contains extension methods for the type system.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetAllBaseTypes(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets all base types.
            </summary>
            <remarks>This is the reflexive and transitive closure of <see cref="P:ICSharpCode.NRefactory.TypeSystem.IType.DirectBaseTypes"/>.
            Note that this method does not return all supertypes - doing so is impossible due to contravariance
            (and undesirable for covariance as the list could become very large).
            
            The output is ordered so that base types occur before derived types.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetNonInterfaceBaseTypes(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets all non-interface base types.
            </summary>
            <remarks>
            When <paramref name="type"/> is an interface, this method will also return base interfaces (return same output as GetAllBaseTypes()).
            
            The output is ordered so that base types occur before derived types.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetAllBaseTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets all base type definitions.
            The output is ordered so that base types occur before derived types.
            </summary>
            <remarks>
            This is equivalent to type.GetAllBaseTypes().Select(t => t.GetDefinition()).Where(d => d != null).Distinct().
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.IsDerivedFrom(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Gets whether this type definition is derived from the base type definition.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.IsOpen(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the type is an open type (contains type parameters).
            </summary>
            <example>
            <code>
            class X&lt;T&gt; {
              List&lt;T&gt; open;
              X&lt;X&lt;T[]&gt;&gt; open;
              X&lt;string&gt; closed;
              int closed;
            }
            </code>
            </example>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetTypeParameterOwner(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the entity that owns the type parameters occurring in the specified type.
            If both class and method type parameters are present, the method is returned.
            Returns null if the specified type is closed.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.IsOpen(ICSharpCode.NRefactory.TypeSystem.IType)"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.IsUnbound(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the type is unbound (is a generic type, but no type arguments were provided).
            </summary>
            <remarks>
            In "<c>typeof(List&lt;Dictionary&lt;,&gt;&gt;)</c>", only the Dictionary is unbound, the List is considered
            bound despite containing an unbound type.
            This method returns false for partially parameterized types (<c>Dictionary&lt;string, &gt;</c>).
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.IsKnownType(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.KnownTypeCode)">
            <summary>
            Gets whether the type is the specified known type.
            For generic known types, this returns true any parameterization of the type (and also for the definition itself).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Imports a type from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Imports a type from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Imports an entity from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IMember)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IMethod)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IField)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IEvent)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IProperty)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.INamespace)">
            <summary>
            Imports a namespace from another compilation.
            </summary>
            <remarks>
            This method may return null if the namespace does not exist in the target compilation.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetDelegateInvokeMethod(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the invoke method for a delegate type.
            </summary>
            <remarks>
            Returns null if the type is not a delegate type; or if the invoke method could not be found.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetAllTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile)">
            <summary>
            Gets all unresolved type definitions from the file.
            For partial classes, each part is returned.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetAllTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly)">
            <summary>
            Gets all unresolved type definitions from the assembly.
            For partial classes, each part is returned.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetAllTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.ICompilation)">
            <summary>
            Gets all type definitions in the compilation.
            This may include types from referenced assemblies that are not accessible in the main assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetInnermostTypeDefinition(ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile,System.Int32,System.Int32)">
            <summary>
            Gets the type (potentially a nested type) defined at the specified location.
            Returns null if no type is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetMember(ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile,System.Int32,System.Int32)">
            <summary>
            Gets the member defined at the specified location.
            Returns null if no member is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetSubTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Gets all sub type definitions defined in a context.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.FindType(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.FullTypeName)">
            <summary>
            Retrieves the specified type in this compilation.
            Returns an <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType"/> if the type cannot be found in this compilation.
            </summary>
            <remarks>
            There can be multiple types with the same full name in a compilation, as a
            full type name is only unique per assembly.
            If there are multiple possible matches, this method will return just one of them.
            When possible, use <see cref="M:ICSharpCode.NRefactory.TypeSystem.IAssembly.GetTypeDefinition(ICSharpCode.NRefactory.TypeSystem.TopLevelTypeName)"/> instead to
            retrieve a type from a specific assembly.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetTypeDefinition(ICSharpCode.NRefactory.TypeSystem.IAssembly,ICSharpCode.NRefactory.TypeSystem.FullTypeName)">
            <summary>
            Gets the type definition for the specified unresolved type.
            Returns null if the unresolved type does not belong to this assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeReference,ICSharpCode.NRefactory.TypeSystem.ICompilation)">
            <summary>
            Resolves a type reference in the compilation's main type resolve context.
            Some type references require a more specific type resolve context and will not resolve using this method.
            </summary>
            <returns>
            Returns the resolved type.
            In case of an error, returns <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>.
            Never returns null.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TypeSystemExtensions.GetTypeDefinition(ICSharpCode.NRefactory.TypeSystem.IAssembly,System.String,System.String,System.Int32)">
            <summary>
            Gets the type definition for a top-level type.
            </summary>
            <remarks>This method uses ordinal name comparison, not the compilation's name comparer.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.FullTypeName">
            <summary>
            Holds the full name of a type definition.
            A full type name uniquely identifies a type definition within a single assembly.
            </summary>
            <remarks>
            A full type name can only represent type definitions, not arbitrary types.
            It does not include any type arguments, and can not refer to array or pointer types.
            
            A full type name represented as reflection name has the syntax:
            <c>NamespaceName '.' TopLevelTypeName ['`'#] { '+' NestedTypeName ['`'#] }</c>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.FullTypeName.#ctor(ICSharpCode.NRefactory.TypeSystem.TopLevelTypeName)">
            <summary>
            Constructs a FullTypeName representing the given top-level type.
            </summary>
            <remarks>
            FullTypeName has an implicit conversion operator from TopLevelTypeName,
            so you can simply write:
            <c>FullTypeName f = new TopLevelTypeName(...);</c>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.FullTypeName.#ctor(System.String)">
            <summary>
            Constructs a FullTypeName by parsing the given reflection name.
            Note that FullTypeName can only represent type definition names. If the reflection name
            might refer to a parameterized type or array etc., use
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)"/> instead.
            </summary>
            <remarks>
            Expected syntax: <c>NamespaceName '.' TopLevelTypeName ['`'#] { '+' NestedTypeName ['`'#] }</c>
            where # are type parameter counts
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.FullTypeName.GetNestedTypeName(System.Int32)">
            <summary>
            Gets the name of the nested type at the given level.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.FullTypeName.GetNestedTypeAdditionalTypeParameterCount(System.Int32)">
            <summary>
            Gets the number of additional type parameters of the nested type at the given level.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.FullTypeName.GetDeclaringType">
            <summary>
            Gets the declaring type name.
            </summary>
            <exception cref="T:System.InvalidOperationException">This is a top-level type name.</exception>
            <example><c>new FullTypeName("NS.A+B+C").GetDeclaringType()</c> will return <c>new FullTypeName("NS.A+B")</c></example>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.FullTypeName.NestedType(System.String,System.Int32)">
            <summary>
            Creates a nested type name.
            </summary>
            <example><c>new FullTypeName("NS.A+B").NestedType("C", 1)</c> will return <c>new FullTypeName("NS.A+B+C`1")</c></example>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.FullTypeName.TopLevelTypeName">
            <summary>
            Gets the top-level type name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.FullTypeName.IsNested">
            <summary>
            Gets whether this is a nested type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.FullTypeName.NestingLevel">
            <summary>
            Gets the nesting level.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.FullTypeName.Name">
            <summary>
            Gets the name of the type.
            For nested types, this is the name of the innermost type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.FullTypeName.TypeParameterCount">
            <summary>
            Gets the total type parameter count.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.None">
            <summary>
            Convert only the name.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowParameterList">
            <summary>
            Show the parameter list
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowParameterNames">
            <summary>
            Show names for parameters
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowAccessibility">
            <summary>
            Show the accessibility (private, public, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowDefinitionKeyword">
            <summary>
            Show the definition key word (class, struct, Sub, Function, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowDeclaringType">
            <summary>
            Show the declaring type for the member
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowModifiers">
            <summary>
            Show modifiers (virtual, override, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowReturnType">
            <summary>
            Show the return type
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.UseFullyQualifiedTypeNames">
            <summary>
            Use fully qualified names for types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowTypeParameterList">
            <summary>
            Show the list of type parameters on method and class declarations.
            Type arguments for parameter/return types are always shown.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowBody">
            <summary>
            For fields, events and methods: adds a semicolon at the end.
            For properties: shows "{ get; }" or similar.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ICompilation.GetNamespaceForExternAlias(System.String)">
            <summary>
            Gets the root namespace for a given extern alias.
            </summary>
            <remarks>
            If <paramref name="alias"/> is <c>null</c> or an empty string, this method
            returns the global root namespace.
            If no alias with the specified name exists, this method returns null.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.MainAssembly">
            <summary>
            Gets the current assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.TypeResolveContext">
            <summary>
            Gets the type resolve context that specifies this compilation and no current assembly or entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.Assemblies">
            <summary>
            Gets the list of all assemblies in the compilation.
            </summary>
            <remarks>
            This main assembly is the first entry in the list.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.ReferencedAssemblies">
            <summary>
            Gets the referenced assemblies.
            This list does not include the main assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.RootNamespace">
            <summary>
            Gets the root namespace of this compilation.
            This is a merged version of the root namespaces of all assemblies.
            </summary>
            <remarks>
            This always is the namespace without a name - it's unrelated to the 'root namespace' project setting.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.NameComparer">
            <summary>
            Gets the name comparer for the language being compiled.
            This is the string comparer used for the INamespace.GetTypeDefinition method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember">
            <summary>
            Method/field/property/event.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IMemberReference.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the member.
            </summary>
            <param name="context">
            Context to use for resolving this member reference.
            Which kind of context is required depends on the which kind of member reference this is;
            please consult the documentation of the method that was used to create this member reference,
            or that of the class implementing this method.
            </param>
            <returns>
            Returns the resolved member, or <c>null</c> if the member could not be found.
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMemberReference.DeclaringTypeReference">
            <summary>
            Gets the declaring type reference for the member.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the member.
            </summary>
            <param name="context">
            Context for looking up the member. The context must specify the current assembly.
            A <see cref="T:ICSharpCode.NRefactory.TypeSystem.SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
            </param>
            <returns>
            Returns the resolved member, or <c>null</c> if the member could not be found.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.CreateResolved(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Creates the resolved member.
            </summary>
            <param name="context">
            The language-specific context that includes the parent type definition.
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition.CreateResolveContext(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)"/>
            </param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.ReturnType">
            <summary>
            Gets the return type of this member.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.IsExplicitInterfaceImplementation">
            <summary>
            Gets whether this member is explicitly implementing an interface.
            If this property is true, the member can only be called through the interfaces it implements.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.ExplicitInterfaceImplementations">
            <summary>
            Gets the interfaces that are explicitly implemented by this member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.IsVirtual">
            <summary>
            Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
            members can be overridden, too; if they are abstract or overriding a method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.IsOverride">
            <summary>
            Gets whether this member is overriding another member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.IsOverridable">
            <summary>
            Gets if the member can be overridden. Returns true when the member is "abstract", "virtual" or "override" but not "sealed".
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEvent.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the member.
            </summary>
            <param name="context">
            Context for looking up the member. The context must specify the current assembly.
            A <see cref="T:ICSharpCode.NRefactory.TypeSystem.SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
            </param>
            <returns>
            Returns the resolved member, or <c>null</c> if the member could not be found.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField">
            <summary>
            Represents a field or constant.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the member.
            </summary>
            <param name="context">
            Context for looking up the member. The context must specify the current assembly.
            A <see cref="T:ICSharpCode.NRefactory.TypeSystem.SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
            </param>
            <returns>
            Returns the resolved member, or <c>null</c> if the member could not be found.
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField.IsReadOnly">
            <summary>
            Gets whether this field is readonly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField.IsVolatile">
            <summary>
            Gets whether this field is volatile.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField.IsConst">
            <summary>
            Gets whether this field is a constant (C#-like const).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IField">
            <summary>
            Represents a field or constant.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IVariable">
            <summary>
            Represents a variable (name/type pair).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Name">
            <summary>
            Gets the name of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Region">
            <summary>
            Gets the declaration region of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Type">
            <summary>
            Gets the type of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.IsConst">
            <summary>
            Gets whether this variable is a constant (C#-like const).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.ConstantValue">
            <summary>
            If this field is a constant, retrieves the value.
            For parameters, this is the default value.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.Name">
            <summary>
            Gets the name of the field.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.Region">
            <summary>
            Gets the region where the field is declared.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.IsReadOnly">
            <summary>
            Gets whether this field is readonly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.IsVolatile">
            <summary>
            Gets whether this field is volatile.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.InterningProvider">
            <summary>
            Provider used for interning.
            </summary>
            <remarks>
            A simple IInterningProvider implementation could use 3 dictionaries:
             1. using value equality comparer (for certain types known to implement value equality, e.g. string and IType)
             2. using comparer that calls into ISupportsInterning (for types implementing ISupportsInterning)
             3. list comparer (for InternList method)
            
            On the first Intern()-call, the provider tells the object to prepare for interning (ISupportsInterning.PrepareForInterning)
            and stores it into a dictionary. On further Intern() calls, the original object is returned for all equal objects.
            This allows reducing the memory usage by using a single object instance where possible.
            
            Interning provider implementations could also use the interning logic for different purposes:
            for example, it could be used to determine which objects are used jointly between multiple type definitions
            and which are used only within a single type definition. Then a persistent file format could be organized so
            that shared objects are loaded only once, yet non-shared objects get loaded lazily together with the class.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InterningProvider.Intern(ICSharpCode.NRefactory.TypeSystem.ISupportsInterning)">
            <summary>
            Interns the specified object.
            
            If the object is freezable, it will be frozen.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InterningProvider.Intern``1(``0)">
            <summary>
            Interns the specified object.
            
            If the object is freezable, it will be frozen.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InterningProvider.Intern(System.String)">
            <summary>
            Interns the specified string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InterningProvider.InternValue(System.Object)">
            <summary>
            Inters a boxed value type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InterningProvider.InternList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Interns the given list. Uses reference equality to compare the list elements.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameterizedMember">
            <summary>
            Represents a method or property.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the member.
            </summary>
            <param name="context">
            Context for looking up the member. The context must specify the current assembly.
            A <see cref="T:ICSharpCode.NRefactory.TypeSystem.SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
            </param>
            <returns>
            Returns the resolved member, or <c>null</c> if the member could not be found.
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod.ReturnTypeAttributes">
            <summary>
            Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod.IsPartial">
            <summary>
            Gets whether the method is a C#-style partial method.
            Check <see cref="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod.HasBody"/> to test if it is a partial method declaration or implementation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod.IsAsync">
            <summary>
            Gets whether the method is a C#-style async method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod.HasBody">
            <summary>
            Gets whether the method has a body.
            This property returns <c>false</c> for <c>abstract</c> or <c>extern</c> methods,
            or for <c>partial</c> methods without implementation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod.AccessorOwner">
            <summary>
            If this method is an accessor, returns a reference to the corresponding property/event.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter">
            <summary>
            Type parameter of a generic class/method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.OwnerType">
            <summary>
            Get the type of this type parameter's owner.
            </summary>
            <returns>EntityType.TypeDefinition or EntityType.Method</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Owner">
            <summary>
            Gets the owning method/class.
            This property may return null (for example for the dummy type parameters used by <see cref="M:ICSharpCode.NRefactory.TypeSystem.ParameterListComparer.NormalizeMethodTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)"/>).
            </summary>
            <remarks>
            For "class Outer&lt;T&gt; { class Inner {} }",
            inner.TypeParameters[0].Owner will be the outer class, because the same
            ITypeParameter instance is used both on Outer`1 and Outer`1+Inner.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Index">
            <summary>
            Gets the index of the type parameter in the type parameter list of the owning method/class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Attributes">
            <summary>
            Gets the list of attributes declared on this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Variance">
            <summary>
            Gets the variance of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Region">
            <summary>
            Gets the region where the type parameter is defined.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.EffectiveBaseClass">
            <summary>
            Gets the effective base class of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.EffectiveInterfaceSet">
            <summary>
            Gets the effective interface set of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasDefaultConstructorConstraint">
            <summary>
            Gets if the type parameter has the 'new()' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasReferenceTypeConstraint">
            <summary>
            Gets if the type parameter has the 'class' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasValueTypeConstraint">
            <summary>
            Gets if the type parameter has the 'struct' constraint.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedMember">
            <summary>
            Base class for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember"/> implementations.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AccessorOwnerMemberReference">
            <summary>
            Given a reference to an accessor, returns the accessor's owner.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.BaseTypeCollector">
            <summary>
            Helper class for the GetAllBaseTypes() implementation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Implementation.BaseTypeCollector.SkipImplementedInterfaces">
            <summary>
            If this option is enabled, the list will not contain interfaces when retrieving the base types
            of a class.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAssemblyReference">
            <summary>
            References an existing assembly by name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAttribute">
            <summary>
            IAttribute implementation for already-resolved attributes.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultMemberReference">
            <summary>
            References an entity by its type and name.
            This class can be used to refer to all members except for constructors and explicit interface implementations.
            </summary>
            <remarks>
            Resolving a DefaultMemberReference requires a context that provides enough information for resolving the declaring type reference
            and the parameter types references.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultParameter">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IParameter"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.Attributes">
            <summary>
            Gets the list of attributes.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsRef">
            <summary>
            Gets whether this parameter is a C# 'ref' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsOut">
            <summary>
            Gets whether this parameter is a C# 'out' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsParams">
            <summary>
            Gets whether this parameter is a C# 'params' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsOptional">
            <summary>
            Gets whether this parameter is optional.
            The default value is given by the <see cref="P:ICSharpCode.NRefactory.TypeSystem.IVariable.ConstantValue"/> property.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedTypeDefinition">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition">
            <summary>
            Represents a class, enum, interface, struct, delegate or VB module.
            For partial classes, this represents the whole class.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.GetInterfaceImplementation(ICSharpCode.NRefactory.TypeSystem.IMember)">
            <summary>
            Determines how this type is implementing the specified interface member.
            </summary>
            <returns>
            The method on this type that implements the interface member;
            or null if the type does not implement the interface.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.GetInterfaceImplementation(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IMember})">
            <summary>
            Determines how this type is implementing the specified interface members.
            </summary>
            <returns>
            For each interface member, this method returns the class member 
            that implements the interface member.
            For interface members that are missing an implementation, the
            result collection will contain a null element.
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.Parts">
            <summary>
            Returns all parts that contribute to this type definition.
            Non-partial classes have a single part that represents the whole class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.KnownTypeCode">
            <summary>
            Gets the known type code for this type definition.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.EnumUnderlyingType">
            <summary>
            For enums: returns the underlying primitive type.
            For all other types: returns <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.FullTypeName">
            <summary>
            Gets the full name of this type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.DeclaringType">
            <summary>
            Gets/Sets the declaring type (incl. type arguments, if any).
            This property never returns null -- for top-level entities, it returns SharedTypes.UnknownType.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.HasExtensionMethods">
            <summary>
            Gets whether this type contains extension methods.
            </summary>
            <remarks>This property is used to speed up the search for extension methods.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAttribute">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedEvent">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEvent"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedField">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod"/> interface.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod.DummyConstructor">
            <summary>
            Returns a dummy constructor instance:
            </summary>
            <returns>
            A public instance constructor with IsSynthetic=true and no declaring type.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedParameter">
            <summary>
            Default implementation for IUnresolvedParameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.Name">
            <summary>
            Gets the name of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.Region">
            <summary>
            Gets the declaration region of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.Type">
            <summary>
            Gets the type of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.Attributes">
            <summary>
            Gets the list of attributes.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.IsRef">
            <summary>
            Gets whether this parameter is a C# 'ref' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.IsOut">
            <summary>
            Gets whether this parameter is a C# 'out' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.IsParams">
            <summary>
            Gets whether this parameter is a C# 'params' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.IsOptional">
            <summary>
            Gets whether this parameter is optional.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedProperty">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedProperty"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedProperty">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedProperty.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the member.
            </summary>
            <param name="context">
            Context for looking up the member. The context must specify the current assembly.
            A <see cref="T:ICSharpCode.NRefactory.TypeSystem.SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
            </param>
            <returns>
            Returns the resolved member, or <c>null</c> if the member could not be found.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeDefinition">
            <summary>
            Represents an unresolved type definition.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeParameter">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter">
            <summary>
            Type parameter of a generic class/method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.OwnerType">
            <summary>
            Get the type of this type parameter's owner.
            </summary>
            <returns>EntityType.TypeDefinition or EntityType.Method</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.Index">
            <summary>
            Gets the index of the type parameter in the type parameter list of the owning method/class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.Attributes">
            <summary>
            Gets the list of attributes declared on this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.Variance">
            <summary>
            Gets the variance of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.Region">
            <summary>
            Gets the region where the type parameter is defined.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeParameter.ApplyInterningProvider(ICSharpCode.NRefactory.TypeSystem.InterningProvider)">
            <summary>
            Uses the specified interning provider to intern
            strings and lists in this entity.
            This method does not test arbitrary objects to see if they implement ISupportsInterning;
            instead we assume that those are interned immediately when they are created (before they are added to this entity).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DummyTypeParameter.NormalizeMethodTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Replaces all occurrences of method type parameters in the given type
            by normalized type parameters. This allows comparing parameter types from different
            generic methods.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DummyTypeParameter.NormalizeClassTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Replaces all occurrences of class type parameters in the given type
            by normalized type parameters. This allows comparing parameter types from different
            generic methods.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DummyTypeParameter.NormalizeAllTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Replaces all occurrences of class and method type parameters in the given type
            by normalized type parameters. This allows comparing parameter types from different
            generic methods.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.ExplicitInterfaceImplementationMemberReference">
            <summary>
            References a member that is an explicit interface implementation.
            </summary>
            <remarks>
            Resolving an ExplicitInterfaceImplementationMemberReference requires a context
            that provides enough information for resolving the declaring type reference
            and the interface member reference.
            Note that the interface member reference is resolved in '<c>context.WithCurrentTypeDefinition(declaringType.GetDefinition())</c>'
            - this is done to ensure that open generics in the interface member reference resolve to the type parameters of the
            declaring type.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference">
            <summary>
            Type Reference used when the fully qualified type name is known.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.FullTypeName,ICSharpCode.NRefactory.TypeSystem.IAssemblyReference)">
            <summary>
            Creates a new GetClassTypeReference that searches a type definition.
            </summary>
            <param name="fullTypeName">The full name of the type.</param>
            <param name="assembly">A reference to the assembly containing this type.
            If this parameter is null, the GetClassTypeReference will search in all
            assemblies belonging to the compilation.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new GetClassTypeReference that searches a top-level type in all assemblies.
            </summary>
            <param name="namespaceName">The namespace name containing the type, e.g. "System.Collections.Generic".</param>
            <param name="name">The name of the type, e.g. "List".</param>
            <param name="typeParameterCount">The number of type parameters, (e.g. 1 for List&lt;T&gt;).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.IAssemblyReference,System.String,System.String,System.Int32)">
            <summary>
            Creates a new GetClassTypeReference that searches a top-level type in the specified assembly.
            </summary>
            <param name="assembly">A reference to the assembly containing this type.
            If this parameter is null, the GetClassTypeReference will search in all assemblies belonging to the ICompilation.</param>
            <param name="namespaceName">The namespace name containing the type, e.g. "System.Collections.Generic".</param>
            <param name="name">The name of the type, e.g. "List".</param>
            <param name="typeParameterCount">The number of type parameters, (e.g. 1 for List&lt;T&gt;).</param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.Assembly">
            <summary>
            Gets the assembly reference.
            This property returns null if the GetClassTypeReference is searching in all assemblies
            of the compilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.FullTypeName">
            <summary>
            Gets the full name of the type this reference is searching for.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetMembersHelper">
            <summary>
            Provides helper methods for implementing GetMembers() on IType-implementations.
            Note: GetMembersHelper will recursively call back into IType.GetMembers(), but only with
            both GetMemberOptions.IgnoreInheritedMembers and GetMemberOptions.ReturnMemberDefinitions set,
            and only the 'simple' overloads (not taking type arguments).
            
            Ensure that your IType implementation does not use the GetMembersHelper if both flags are set,
            otherwise you'll get a StackOverflowException!
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.KnownTypeCache">
            <summary>
            Cache for KnownTypeReferences.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace">
            <summary>
            A merged namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace.#ctor(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.INamespace[],System.String)">
            <summary>
            Creates a new merged root namespace.
            </summary>
            <param name="compilation">The main compilation.</param>
            <param name="namespaces">The individual namespaces being merged.</param>
            <param name="externAlias">The extern alias for this namespace.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace.#ctor(ICSharpCode.NRefactory.TypeSystem.INamespace,ICSharpCode.NRefactory.TypeSystem.INamespace[])">
            <summary>
            Creates a new merged child namespace.
            </summary>
            <param name="parentNamespace">The parent merged namespace.</param>
            <param name="namespaces">The individual namespaces being merged.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.MinimalCorlib">
            <summary>
            Resolve context represents the minimal mscorlib required for evaluating constants.
            This contains all known types (<see cref="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode"/>) and no other types.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference">
            <summary>
            Type reference used to reference nested types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.String,System.Int32)">
            <summary>
            Creates a new NestedTypeReference.
            </summary>
            <param name="declaringTypeRef">Reference to the declaring type.</param>
            <param name="name">Name of the nested class</param>
            <param name="additionalTypeParameterCount">Number of type parameters on the inner class (without type parameters on baseTypeRef)</param>
            <remarks>
            <paramref name="declaringTypeRef"/> must be exactly the (unbound) declaring type, not a derived type, not a parameterized type.
            NestedTypeReference thus always resolves to a type definition, never to (partially) parameterized types.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleCompilation">
            <summary>
            Simple compilation implementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleConstantValue">
            <summary>
            A simple constant value that is independent of the resolve context.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleInterningProvider">
            <summary>
            Simple interning provider.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedEvent">
            <summary>
            Represents a specialized IEvent (event after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMember">
            <summary>
            Represents a SpecializedMember (a member on which type substitution has been performed).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMember.AddSubstitution(ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Performs a substitution. This method may only be called by constructors in derived classes.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMember.Substitution">
            <summary>
            Gets the substitution belonging to this specialized member.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedField">
            <summary>
            Represents a specialized IField (field after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod">
            <summary>
            Represents a specialized IMethod (e.g. after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty">
            <summary>
            Represents a specialized IProperty (property after type substitution).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeParameterReference.Create(ICSharpCode.NRefactory.TypeSystem.EntityType,System.Int32)">
            <summary>
            Creates a type parameter reference.
            For common type parameter references, this method may return a shared instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType">
            <summary>
            An unknown type where (part) of the name is known.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new unknown type.
            </summary>
            <param name="namespaceName">Namespace name, if known. Can be null if unknown.</param>
            <param name="name">Name of the type, must not be null.</param>
            <param name="typeParameterCount">Type parameter count, zero if unknown.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType.#ctor(ICSharpCode.NRefactory.TypeSystem.FullTypeName)">
            <summary>
            Creates a new unknown type.
            </summary>
            <param name="fullTypeName">Full name of the unknown type.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.VoidTypeDefinition">
            <summary>
            Special type definition for 'void'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.InheritanceHelper">
            <summary>
            Provides helper methods for inheritance.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InheritanceHelper.GetBaseMember(ICSharpCode.NRefactory.TypeSystem.IMember)">
            <summary>
            Gets the base member that has the same signature.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InheritanceHelper.GetBaseMembers(ICSharpCode.NRefactory.TypeSystem.IMember,System.Boolean)">
            <summary>
            Gets all base members that have the same signature.
            </summary>
            <returns>
            List of base members with the same signature. The member from the derived-most base class is returned first.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InheritanceHelper.GetDerivedMember(ICSharpCode.NRefactory.TypeSystem.IMember,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Finds the member declared in 'derivedType' that has the same signature (could override) 'baseMember'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType">
            <summary>
            Represents the intersection of several types.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile">
            <summary>
            Represents a single file that was parsed.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.GetTopLevelTypeDefinition(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets the top-level type defined at the specified location.
            Returns null if no type is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.GetInnermostTypeDefinition(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets the type (potentially a nested type) defined at the specified location.
            Returns null if no type is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.GetMember(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets the member defined at the specified location.
            Returns null if no member is defined at that location.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.FileName">
            <summary>
            Returns the full path of the file.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.LastWriteTime">
            <summary>
            Gets the time when the file was last written.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.TopLevelTypeDefinitions">
            <summary>
            Gets all top-level type definitions.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.AssemblyAttributes">
            <summary>
            Gets all assembly attributes that are defined in this file.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.ModuleAttributes">
            <summary>
            Gets all module attributes that are defined in this file.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile.Errors">
            <summary>
            Gets the parser errors.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IProjectContent">
            <summary>
            Represents an assembly consisting of source code (parsed files).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.GetFile(System.String)">
            <summary>
            Gets a parsed file by its file name.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.CreateCompilation">
            <summary>
            Creates a new <see cref="T:ICSharpCode.NRefactory.TypeSystem.ICompilation"/> that allows resolving within this project.
            </summary>
            <remarks>
            This method does not support <see cref="T:ICSharpCode.NRefactory.TypeSystem.ProjectReference"/>s. When dealing with a solution
            containing multiple projects, consider using <see cref="M:ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot.GetCompilation(ICSharpCode.NRefactory.TypeSystem.IProjectContent)"/> instead.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.CreateCompilation(ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot)">
            <summary>
            Creates a new <see cref="T:ICSharpCode.NRefactory.TypeSystem.ICompilation"/> that allows resolving within this project.
            </summary>
            <param name="solutionSnapshot">The parent solution snapshot to use for the compilation.</param>
            <remarks>
            This method is intended to be called by ISolutionSnapshot implementations. Other code should
            call <see cref="M:ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot.GetCompilation(ICSharpCode.NRefactory.TypeSystem.IProjectContent)"/> instead.
            This method always creates a new compilation, even if the solution snapshot already contains
            one for this project.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.SetAssemblyName(System.String)">
            <summary>
            Changes the assembly name of this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.SetProjectFileName(System.String)">
            <summary>
            Changes the project file name of this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.SetLocation(System.String)">
            <summary>
            Changes the path to the assembly location (the output path where the project compiles to).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.AddAssemblyReferences(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IAssemblyReference})">
            <summary>
            Add assembly references to this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.AddAssemblyReferences(ICSharpCode.NRefactory.TypeSystem.IAssemblyReference[])">
            <summary>
            Add assembly references to this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.RemoveAssemblyReferences(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IAssemblyReference})">
            <summary>
            Removes assembly references from this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.RemoveAssemblyReferences(ICSharpCode.NRefactory.TypeSystem.IAssemblyReference[])">
            <summary>
            Removes assembly references from this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.AddOrUpdateFiles(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile})">
            <summary>
            Adds the specified files to the project content.
            If a file with the same name already exists, updated the existing file.
            </summary>
            <remarks>
            You can create an unresolved file by calling <c>ToTypeSystem()</c> on a syntax tree.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.AddOrUpdateFiles(ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile[])">
            <summary>
            Adds the specified files to the project content.
            If a file with the same name already exists, this method updates the existing file.
            </summary>
            <remarks>
            You can create an unresolved file by calling <c>ToTypeSystem()</c> on a syntax tree.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.RemoveFiles(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Removes the files with the specified names.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.RemoveFiles(System.String[])">
            <summary>
            Removes the files with the specified names.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.UpdateProjectContent(ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile,ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile)">
            <summary>
            Removes types and attributes from oldFile from the project, and adds those from newFile.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.UpdateProjectContent(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile})">
            <summary>
            Removes types and attributes from oldFiles from the project, and adds those from newFiles.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.SetCompilerSettings(System.Object)">
            <summary>
            Sets the compiler settings object.
            The concrete type of the settings object depends on the programming language used to implement this project.
            Using the incorrect type of settings object results in an <see cref="T:System.ArgumentException"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IProjectContent.ProjectFileName">
            <summary>
            Gets the path to the project file (e.g. .csproj).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IProjectContent.Files">
            <summary>
            Gets the list of all files in the project content.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IProjectContent.AssemblyReferences">
            <summary>
            Gets the referenced assemblies.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IProjectContent.CompilerSettings">
            <summary>
            Gets the compiler settings object.
            The concrete type of the settings object depends on the programming language used to implement this project.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.GetMemberOptions.None">
            <summary>
            No options specified - this is the default.
            Members will be specialized, and inherited members will be included.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.GetMemberOptions.ReturnMemberDefinitions">
            <summary>
            Do not specialize the returned members - directly return the definitions.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.GetMemberOptions.IgnoreInheritedMembers">
            <summary>
            Do not list inherited members - only list members defined directly on this type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.VarianceModifier">
            <summary>
            Represents the variance of a type parameter.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Invariant">
            <summary>
            The type parameter is not variant.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Covariant">
            <summary>
            The type parameter is covariant (used in output position).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Contravariant">
            <summary>
            The type parameter is contravariant (used in input position).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentAssembly">
            <summary>
            Gets the current assembly.
            This property may return null if this context does not specify any assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentTypeDefinition">
            <summary>
            Gets the current type definition.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentMember">
            <summary>
            Gets the current member.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode">
            <summary>
            Represents some well-known types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.None">
            <summary>
            Not one of the known types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Object">
            <summary><c>object</c> (System.Object)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.DBNull">
            <summary><c>System.DBNull</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Boolean">
            <summary><c>bool</c> (System.Boolean)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Char">
            <summary><c>char</c> (System.Char)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.SByte">
            <summary><c>sbyte</c> (System.SByte)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Byte">
            <summary><c>byte</c> (System.Byte)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Int16">
            <summary><c>short</c> (System.Int16)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.UInt16">
            <summary><c>ushort</c> (System.UInt16)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Int32">
            <summary><c>int</c> (System.Int32)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.UInt32">
            <summary><c>uint</c> (System.UInt32)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Int64">
            <summary><c>long</c> (System.Int64)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.UInt64">
            <summary><c>ulong</c> (System.UInt64)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Single">
            <summary><c>float</c> (System.Single)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Double">
            <summary><c>double</c> (System.Double)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Decimal">
            <summary><c>decimal</c> (System.Decimal)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.DateTime">
            <summary><c>System.DateTime</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.String">
            <summary><c>string</c> (System.String)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Void">
            <summary><c>void</c> (System.Void)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Type">
            <summary><c>System.Type</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Array">
            <summary><c>System.Array</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Attribute">
            <summary><c>System.Attribute</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.ValueType">
            <summary><c>System.ValueType</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Enum">
            <summary><c>System.Enum</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Delegate">
            <summary><c>System.Delegate</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.MulticastDelegate">
            <summary><c>System.MulticastDelegate</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Exception">
            <summary><c>System.Exception</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IntPtr">
            <summary><c>System.IntPtr</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.UIntPtr">
            <summary><c>System.UIntPtr</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IEnumerable">
            <summary><c>System.Collections.IEnumerable</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IEnumerator">
            <summary><c>System.Collections.IEnumerator</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IEnumerableOfT">
            <summary><c>System.Collections.Generic.IEnumerable{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IEnumeratorOfT">
            <summary><c>System.Collections.Generic.IEnumerator{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.ICollection">
            <summary><c>System.Collections.Generic.ICollection</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.ICollectionOfT">
            <summary><c>System.Collections.Generic.ICollection{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IList">
            <summary><c>System.Collections.Generic.IList</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IListOfT">
            <summary><c>System.Collections.Generic.IList{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IReadOnlyListOfT">
            <summary><c>System.Collections.Generic.IReadOnlyList{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Task">
            <summary><c>System.Threading.Tasks.Task</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.TaskOfT">
            <summary><c>System.Threading.Tasks.Task{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.NullableOfT">
            <summary><c>System.Nullable{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IDisposable">
            <summary><c>System.IDisposable</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.INotifyCompletion">
            <summary><c>System.Runtime.CompilerServices.INotifyCompletion</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.ICriticalNotifyCompletion">
            <summary><c>System.Runtime.CompilerServices.ICriticalNotifyCompletion</c></summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference">
            <summary>
            Contains well-known type references.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Get(ICSharpCode.NRefactory.TypeSystem.KnownTypeCode)">
            <summary>
            Gets the known type reference for the specified type code.
            Returns null for KnownTypeCode.None.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Object">
            <summary>
            Gets a type reference pointing to the <c>object</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.DBNull">
            <summary>
            Gets a type reference pointing to the <c>System.DBNull</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Boolean">
            <summary>
            Gets a type reference pointing to the <c>bool</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Char">
            <summary>
            Gets a type reference pointing to the <c>char</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.SByte">
            <summary>
            Gets a type reference pointing to the <c>sbyte</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Byte">
            <summary>
            Gets a type reference pointing to the <c>byte</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int16">
            <summary>
            Gets a type reference pointing to the <c>short</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt16">
            <summary>
            Gets a type reference pointing to the <c>ushort</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int32">
            <summary>
            Gets a type reference pointing to the <c>int</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt32">
            <summary>
            Gets a type reference pointing to the <c>uint</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int64">
            <summary>
            Gets a type reference pointing to the <c>long</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt64">
            <summary>
            Gets a type reference pointing to the <c>ulong</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Single">
            <summary>
            Gets a type reference pointing to the <c>float</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Double">
            <summary>
            Gets a type reference pointing to the <c>double</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Decimal">
            <summary>
            Gets a type reference pointing to the <c>decimal</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.DateTime">
            <summary>
            Gets a type reference pointing to the <c>System.DateTime</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.String">
            <summary>
            Gets a type reference pointing to the <c>string</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Void">
            <summary>
            Gets a type reference pointing to the <c>void</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Type">
            <summary>
            Gets a type reference pointing to the <c>System.Type</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Array">
            <summary>
            Gets a type reference pointing to the <c>System.Array</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Attribute">
            <summary>
            Gets a type reference pointing to the <c>System.Attribute</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.ValueType">
            <summary>
            Gets a type reference pointing to the <c>System.ValueType</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Enum">
            <summary>
            Gets a type reference pointing to the <c>System.Enum</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Delegate">
            <summary>
            Gets a type reference pointing to the <c>System.Delegate</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.MulticastDelegate">
            <summary>
            Gets a type reference pointing to the <c>System.MulticastDelegate</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Exception">
            <summary>
            Gets a type reference pointing to the <c>System.Exception</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IntPtr">
            <summary>
            Gets a type reference pointing to the <c>System.IntPtr</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UIntPtr">
            <summary>
            Gets a type reference pointing to the <c>System.UIntPtr</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IEnumerable">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.IEnumerable</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IEnumerator">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.IEnumerator</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IEnumerableOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.IEnumerable{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IEnumeratorOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.IEnumerator{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.ICollection">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.ICollection</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.ICollectionOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.ICollection{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IList">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.IList</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IListOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.IList{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IReadOnlyListOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.IReadOnlyList{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Task">
            <summary>
            Gets a type reference pointing to the <c>System.Threading.Tasks.Task</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.TaskOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Threading.Tasks.Task{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.NullableOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Nullable{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IDisposable">
            <summary>
            Gets a type reference pointing to the <c>System.IDisposable</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.INotifyCompletion">
            <summary>
            Gets a type reference pointing to the <c>System.Runtime.CompilerServices.INotifyCompletion</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.ICriticalNotifyCompletion">
            <summary>
            Gets a type reference pointing to the <c>System.Runtime.CompilerServices.ICriticalNotifyCompletion</c> type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.GetCSharpNameByTypeCode(ICSharpCode.NRefactory.TypeSystem.KnownTypeCode)">
            <summary>
            Gets the C# primitive type name from the known type code.
            Returns null if there is no primitive name for the specified type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.NullableType">
            <summary>
            Static helper methods for working with nullable types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.IsNullable(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the specified type is a nullable type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.GetUnderlyingType(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Returns the element type, if <paramref name="type"/> is a nullable type.
            Otherwise, returns the type itself.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.Create(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Creates a nullable type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.Create(ICSharpCode.NRefactory.TypeSystem.ITypeReference)">
            <summary>
            Creates a nullable type reference.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType">
            <summary>
            ParameterizedType represents an instance of a generic type.
            Example: List&lt;string&gt;
            </summary>
            <remarks>
            When getting the members, this type modifies the lists so that
            type parameters in the signatures of the members are replaced with
            the type arguments.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.IType[])">
            <summary>
            Fast internal version of the constructor. (no safety checks)
            Keeps the array that was passed and assumes it won't be modified.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.GetTypeArgument(System.Int32)">
            <summary>
            Same as 'parameterizedType.TypeArguments[index]', but is a bit more efficient (doesn't require the read-only wrapper).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.GetDefinition">
            <summary>
            Gets the definition of the generic type.
            For <c>ParameterizedType</c>, this method never returns null.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.GetSubstitution">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.GetSubstitution(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type,
            and also substitutes method type parameters with the specified method type arguments.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedTypeReference">
            <summary>
            ParameterizedTypeReference is a reference to generic class that specifies the type parameters.
            Example: List&lt;string&gt;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterListComparer">
            <summary>
            Compares parameter lists by comparing the types of all parameters.
            </summary>
            <remarks>
            'ref int' and 'out int' are considered to be equal.
            "Method{T}(T a)" and "Method{S}(S b)" are also considered equal.
            However, "Method(T a)" and "Method(S b)" are not considered equal when the type parameters T and S belong to classes.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterListComparer.NormalizeMethodTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Replaces all occurrences of method type parameters in the given type
            by normalized type parameters. This allows comparing parameter types from different
            generic methods.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SignatureComparer">
            <summary>
            Compares member signatures.
            </summary>
            <remarks>
            This comparer checks for equal short name, equal type parameter count, and equal parameter types (using ParameterListComparer).
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SignatureComparer.Ordinal">
            <summary>
            Gets a signature comparer that uses an ordinal comparison for the member name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ProjectReference">
            <summary>
            References another project content in the same solution.
            Using the <see cref="T:ICSharpCode.NRefactory.TypeSystem.ProjectReference"/> class requires that you 
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ProjectReference.#ctor(System.String)">
            <summary>
            Creates a new reference to the specified project (must be part of the same solution).
            </summary>
            <param name="projectFileName">Full path to the file name. Must be identical to <see cref="P:ICSharpCode.NRefactory.TypeSystem.IProjectContent.ProjectFileName"/> of the target project; do not use a relative path.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">
            <summary>
            Represents an error while parsing a reflection name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SimpleTypeResolveContext">
            <summary>
            Default ITypeResolveContext implementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TopLevelTypeName">
            <summary>
            Holds the name of a top-level type.
            This struct cannot refer to nested classes.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeKind">
            <summary>
            .
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Other">
            <summary>Language-specific type that is not part of NRefactory.TypeSystem itself.</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Class">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/> that is a class.</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Interface">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/> that is an interface.</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Struct">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/> that is a struct.</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Delegate">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/> that is a delegate.</summary>
            <remarks><c>System.Delegate</c> itself is TypeKind.Class</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Enum">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> that is an enum.</summary>
            <remarks><c>System.Enum</c> itself is TypeKind.Class</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Module">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> that is a module (VB).</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Void">
            <summary>The <c>System.Void</c> type.</summary>
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Void"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Unknown">
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Null">
            <summary>The type of the null literal.</summary>
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.NullType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Dynamic">
            <summary>Type representing the C# 'dynamic' type.</summary>
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.Dynamic"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.UnboundTypeArgument">
            <summary>Represents missing type arguments in partially parameterized types.</summary>
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnboundTypeArgument"/>
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.TypeParameter">
            <summary>The type is a type parameter.</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Array">
            <summary>An array type</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.ArrayType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Pointer">
            <summary>A pointer type</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.PointerType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.ByReference">
            <summary>A managed reference type</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.ByReferenceType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Anonymous">
            <summary>An anonymous type</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.AnonymousType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Intersection">
            <summary>Intersection of several types</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType"/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper">
            <summary>
            Static helper methods for reflection names.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.FindType(ICSharpCode.NRefactory.TypeSystem.ICompilation,System.Type)">
            <summary>
            Retrieves the specified type in this compilation.
            Returns <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/> if the type cannot be found in this compilation.
            </summary>
            <remarks>
            This method cannot be used with open types; all type parameters will be substituted
            with <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ToTypeReference(System.Type)">
            <summary>
            Creates a reference to the specified type.
            </summary>
            <param name="type">The type to be converted.</param>
            <returns>Returns the type reference.</returns>
            <remarks>
            If the type is open (contains type parameters '`0' or '``0'),
            an <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext"/> with the appropriate CurrentTypeDefinition/CurrentMember is required
            to resolve the type reference.
            For closed types, the root type resolve context for the compilation is sufficient.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String)">
            <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
            <remarks>Do not use this method with the full name of inner classes.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String,System.Int32@)">
            <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
            <remarks>Do not use this method with the full name of inner classes.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.FindType(ICSharpCode.NRefactory.TypeSystem.ICompilation,System.TypeCode)">
            <summary>
            Retrieves a built-in type using the specified type code.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ToTypeReference(System.TypeCode)">
            <summary>
            Creates a reference to the specified type.
            </summary>
            <param name="typeCode">The type to be converted.</param>
            <returns>Returns the type reference.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.GetTypeCode(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the type code for the specified type, or TypeCode.Empty if none of the other type codes match.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)">
            <summary>
            Parses a reflection name into a type reference.
            </summary>
            <param name="reflectionTypeName">The reflection name of the type.</param>
            <returns>A type reference that represents the reflection name.</returns>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the reflection type name is invalid</exception>
            <remarks>
            If the type is open (contains type parameters '`0' or '``0'),
            an <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext"/> with the appropriate CurrentTypeDefinition/CurrentMember is required
            to resolve the reference to the ITypeParameter.
            For looking up closed, assembly qualified type names, the root type resolve context for the compilation
            is sufficient.
            When looking up a type name that isn't assembly qualified, the type reference will look in
            <see cref="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentAssembly"/> first, and if the type is not found there,
            it will look in all other assemblies of the compilation.
            </remarks>
            <seealso cref="M:ICSharpCode.NRefactory.TypeSystem.FullTypeName.#ctor(System.String)"/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.Null">
            <summary>
            A reflection class used to represent <c>null</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.Dynamic">
            <summary>
            A reflection class used to represent <c>dynamic</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.UnboundTypeArgument">
            <summary>
            A reflection class used to represent an unbound type argument.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SpecialType">
            <summary>
            Contains static implementations of special types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType">
            <summary>
            Gets the type representing resolve errors.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.NullType">
            <summary>
            The null type is used as type of the null literal. It is a reference type without any members; and it is a subtype of all reference types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.Dynamic">
            <summary>
            Type representing the C# 'dynamic' type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnboundTypeArgument">
            <summary>
            A type used for unbound type arguments in partially parameterized types.
            </summary>
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)"/>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BinaryReaderWith7BitEncodedInts">
            <summary>
            A binary reader that can read the output of BinaryWriterWith7BitEncodedInts.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BinaryWriterWith7BitEncodedInts">
            <summary>
            A binary writer that encodes all integers as 7-bit-encoded-ints.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BitVector16">
            <summary>
            Holds 16 boolean values.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BusyManager">
            <summary>
            This class is used to prevent stack overflows by representing a 'busy' flag
            that prevents reentrance when another call is running.
            However, using a simple 'bool busy' is not thread-safe, so we use a
            thread-static BusyManager.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.CacheManager">
            <summary>
            Allows caching values for a specific compilation.
            A CacheManager consists of a for shared instances (shared among all threads working with that resolve context).
            </summary>
            <remarks>This class is thread-safe</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.CallbackOnDispose">
            <summary>
            Invokes an action when it is disposed.
            </summary>
            <remarks>
            This class ensures the callback is invoked at most once,
            even when Dispose is called on multiple threads.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.CSharpPrimitiveCast">
            <summary>
            Static helper method for converting between primitive types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.CSharpPrimitiveCast.Cast(System.TypeCode,System.Object,System.Boolean)">
            <summary>
            Performs a conversion between primitive types.
            Unfortunately we cannot use Convert.ChangeType because it has different semantics
            (e.g. rounding behavior for floats, overflow, etc.), so we write down every possible primitive C# cast
            and let the compiler figure out the exact semantics.
            And we have to do everything twice, once in a checked-block, once in an unchecked-block.
            </summary>
            <exception cref="T:System.OverflowException">Overflow checking is enabled and an overflow occurred.</exception>
            <exception cref="T:System.InvalidCastException">The cast is invalid, e.g. casting a boolean to an integer.</exception>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.ExtensionMethods">
            <summary>
            Contains extension methods for use within NRefactory.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitScanField(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Reflection.FieldInfo)">
            <summary>
            Emit 'scan instance.Field'.
            Stack transition: ... => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitScanValueType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Stack transition: ..., value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitWriteField(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Reflection.Emit.LocalBuilder,System.Reflection.FieldInfo)">
            <summary>
            Emit 'write instance.Field'.
            Stack transition: ... => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.WritePrimitiveValue(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Writes a primitive value of the specified type.
            Stack transition: ..., writer, value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitWriteValueType(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Stack transition: ..., value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.ReadPrimitiveValue(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Reads a primitive value of the specified type.
            Stack transition: ... => ..., value
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitReadValueType(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Stack transition: ..., field-ref => ...
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Utils.FastSerializer.SerializationBinder">
            <summary>
            Gets/Sets the serialization binder that is being used.
            The default value is null, which will cause the FastSerializer to use the
            full assembly and type names.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Utils.FastSerializer.FixedInstances">
            <summary>
            Can be used to set several 'fixed' instances.
            When serializing, such instances will not be included; and any references to a fixed instance
            will be stored as the index in this array.
            When deserializing, the same (or equivalent) instances must be specified, and the deserializer
            will use them in place of the fixed instances.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.SerializationContext.Mark(System.Object)">
            <summary>
            Marks an instance for future scanning.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.FastSerializerVersionAttribute">
            <summary>
            Specifies the version of the class.
            The <see cref="T:ICSharpCode.NRefactory.Utils.FastSerializer"/> will refuse to deserialize an instance that was stored by
            a different version of the class than the current one.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.GraphVizGraph">
            <summary>
            GraphViz graph.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.color">
            <summary>edge stroke color</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.constraint">
            <summary>use edge to affect node ranking</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.fontsize">
            <summary>point size of label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.fontsize">
            <summary>point size of label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.height">
            <summary>minimum height in inches</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.margin">
            <summary>space around label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.shape">
            <summary>node shape</summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.ImmutableStack`1">
            <summary>
            An immutable stack.
            
            Using 'foreach' on the stack will return the items from top to bottom (in the order they would be popped).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.ImmutableStack`1.Empty">
            <summary>
            Gets the empty stack instance.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.Push(`0)">
            <summary>
            Pushes an item on the stack. This does not modify the stack itself, but returns a new
            one with the value pushed.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.Peek">
            <summary>
            Gets the item on the top of the stack.
            </summary>
            <exception cref="T:System.InvalidOperationException">The stack is empty.</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.PeekOrDefault">
            <summary>
            Gets the item on the top of the stack.
            Returns <c>default(T)</c> if the stack is empty.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.Pop">
            <summary>
            Gets the stack with the top item removed.
            </summary>
            <exception cref="T:System.InvalidOperationException">The stack is empty.</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.GetEnumerator">
            <summary>
            Gets an enumerator that iterates through the stack top-to-bottom.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.ToString">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Utils.ImmutableStack`1.IsEmpty">
            <summary>
            Gets if this stack is empty.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.LazyInit.GetOrSet``1(``0@,``0)">
            <summary>
            Atomically performs the following operation:
            - If target is null: stores newValue in target and returns newValue.
            - If target is not null: returns target.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.MultiDictionary`2">
            <summary>
            A dictionary that allows multiple pairs with the same key.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.MultiDictionary`2.RemoveAll(`0)">
            <summary>
            Removes all entries with the specified key.
            </summary>
            <returns>Returns true if at least one entry was removed.</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.Utils.MultiDictionary`2.Count">
            <summary>
            Returns the number of different keys.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.Platform">
            <summary>
            Platform-specific code.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.TreeTraversal">
            <summary>
            Static helper methods for traversing trees.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PreOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
            <param name="root">The root element of the tree.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in pre-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PreOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
            <param name="input">The root elements of the forest.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in pre-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PostOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
            <param name="root">The root element of the tree.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in post-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PostOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
            <param name="input">The root elements of the forest.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in post-order.</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ErrorType">
            <summary>
            Enum that describes the type of an error.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Error">
            <summary>
            Descibes an error during parsing.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Error.#ctor(ICSharpCode.NRefactory.TypeSystem.ErrorType,System.String,ICSharpCode.NRefactory.TypeSystem.DomRegion)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.Error"/> class.
            </summary>
            <param name="errorType">
            The error type.
            </param>
            <param name="message">
            The description of the error.
            </param>
            <param name="region">
            The region of the error.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Error.#ctor(ICSharpCode.NRefactory.TypeSystem.ErrorType,System.String,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.Error"/> class.
            </summary>
            <param name="errorType">
            The error type.
            </param>
            <param name="message">
            The description of the error.
            </param>
            <param name="location">
            The location of the error.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Error.#ctor(ICSharpCode.NRefactory.TypeSystem.ErrorType,System.String,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.Error"/> class.
            </summary>
            <param name="errorType">
            The error type.
            </param>
            <param name="message">
            The description of the error.
            </param>
            <param name="line">
            The line of the error.
            </param>
            <param name="col">
            The column of the error.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Error.#ctor(ICSharpCode.NRefactory.TypeSystem.ErrorType,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.Error"/> class.
            </summary>
            <param name="errorType">
            The error type.
            </param>
            <param name="message">
            The description of the error.
            </param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Error.ErrorType">
            <summary>
            The type of the error.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Error.Message">
            <summary>
            The error description.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Error.Region">
            <summary>
            The region of the error.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Completion.IParameterDataProvider">
            <summary>
            Provides intellisense information for a collection of parametrized members.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Completion.IParameterDataProvider.GetHeading(System.Int32,System.String[],System.Int32)">
            <summary>
            Returns the markup to use to represent the specified method overload
            in the parameter information window.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Completion.IParameterDataProvider.GetDescription(System.Int32,System.Int32)">
            <summary>
            Returns the markup for the description to use to represent the specified method overload
            in the parameter information window.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Completion.IParameterDataProvider.GetParameterDescription(System.Int32,System.Int32)">
            <summary>
            Returns the text to use to represent the specified parameter
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Completion.IParameterDataProvider.GetParameterName(System.Int32,System.Int32)">
            <summary>
            Gets the name of the parameter.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Completion.IParameterDataProvider.GetParameterCount(System.Int32)">
            <summary>
            Returns the number of parameters of the specified method
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Completion.IParameterDataProvider.AllowParameterList(System.Int32)">
            <summary>
            Used for the params lists. (for example "params" in c#).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Completion.IParameterDataProvider.Count">
            <summary>
            Gets the overload count.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Completion.IParameterDataProvider.StartOffset">
            <summary>
            Gets the start offset of the parameter expression node.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.IdStringProvider">
            <summary>
            Provides ID strings for entities. (C# 4.0 spec, §A.3.1)
            ID strings are used to identify members in XML documentation files.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IdStringProvider.GetIdString(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the ID string (C# 4.0 spec, §A.3.1) for the specified entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IdStringProvider.ParseMemberIdString(System.String)">
            <summary>
            Parse the ID string into a member reference.
            </summary>
            <param name="memberIdString">The ID string representing the member (with "M:", "F:", "P:" or "E:" prefix).</param>
            <returns>A member reference that represents the ID string.</returns>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
            <remarks>
            The member reference will look in <see cref="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentAssembly"/> first,
            and if the member is not found there,
            it will look in all other assemblies of the compilation.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IdStringProvider.ParseTypeName(System.String)">
            <summary>
            Parse the ID string type name into a type reference.
            </summary>
            <param name="typeName">The ID string representing the type (the "T:" prefix is optional).</param>
            <returns>A type reference that represents the ID string.</returns>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
            <remarks>
            <para>
            The type reference will look in <see cref="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentAssembly"/> first,
            and if the type is not found there,
            it will look in all other assemblies of the compilation.
            </para>
            <para>
            If the type is open (contains type parameters '`0' or '``0'),
            an <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext"/> with the appropriate CurrentTypeDefinition/CurrentMember is required
            to resolve the reference to the ITypeParameter.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IdStringProvider.FindEntity(System.String,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Finds the entity in the given type resolve context.
            </summary>
            <param name="idString">ID string of the entity.</param>
            <param name="context">Type resolve context</param>
            <returns>Returns the entity, or null if it is not found.</returns>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.CompositeFormatStringParser">
            <summary>
            Composite format string parser.
            </summary>
            <remarks>
            Implements a complete parser for valid strings as well as
            error reporting and best-effort parsing for invalid strings.
            </remarks>		
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.CompositeFormatStringParser.Parse(System.String)">
            <summary>
            Parse the specified format string.
            </summary>
            <param name='format'>
            The format string.
            </param>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.FormatStringSegmentBase">
            <summary>
            Composite format string parser.
            </summary>
            <remarks>
            Implements a complete parser for valid strings as well as
            error reporting and best-effort parsing for invalid strings.
            </remarks>		
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.IFormatStringSegment">
            <summary>
            Composite format string parser.
            </summary>
            <remarks>
            Implements a complete parser for valid strings as well as
            error reporting and best-effort parsing for invalid strings.
            </remarks>		
        </member>
        <member name="M:ICSharpCode.NRefactory.Completion.CompletionExtensionMethods.GetEditorBrowsableState(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the EditorBrowsableState of an entity.
            </summary>
            <returns>
            The editor browsable state.
            </returns>
            <param name='entity'>
            Entity.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Completion.CompletionExtensionMethods.IsBrowsable(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Determines if an entity should be shown in the code completion window. This is the same as:
            <c>GetEditorBrowsableState (entity) != System.ComponentModel.EditorBrowsableState.Never</c>
            </summary>
            <returns>
            <c>true</c> if the entity should be shown; otherwise, <c>false</c>.
            </returns>
            <param name='entity'>
            The entity.
            </param>
        </member>
    </members>
</doc>
