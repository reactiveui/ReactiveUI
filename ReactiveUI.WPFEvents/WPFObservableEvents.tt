<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="PresentationCore" #>
<#@ assembly name="PresentationFramework" #>
<#@ assembly name="System.Xaml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Diagnostics"#>
<#@ import namespace="System.IO"#>
<#@ import namespace="System.Linq"#>
<#@ import namespace="System.Reflection"#>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Threading.Tasks"#>
<#@ import namespace="System.Windows"#>
<#@ import namespace="System.Windows.Controls"#>
<#@ import namespace="System.Windows.Input"#>
<#@ import namespace="System.Windows.Threading"#>
<#@ output extension=".cs" #>
<#
        var UIElementTypes = from t in Assembly.GetAssembly(typeof(UIElement)).GetTypes()
                        where t.IsPublic 
                        select t;

        var FrameworkElementTypes = from t in Assembly.GetAssembly(typeof(FrameworkElement)).GetTypes()
                        where t.IsPublic 
                        select t;

        var WindowsBaseTypes = from t in Assembly.GetAssembly(typeof(Dispatcher)).GetTypes()
                        where t.IsPublic 
                        select t;

        var typesToDo = UIElementTypes.Concat(FrameworkElementTypes).Concat(WindowsBaseTypes).Distinct();

         var usingNamespace = new SortedSet<string>()
            {
                "System.Reactive",
                "System.Reactive.Linq",
                "System.Reactive",
                "System.Reactive.Linq",
                "System.Windows",
                "System.Windows.Controls",
                "System.Windows.Input"
            };


        foreach(var type in typesToDo)
        {
            usingNamespace.Add(type.Namespace);
            foreach(var e in type.GetEvents())
            {
                usingNamespace.Add(e.EventHandlerType.Namespace);
                usingNamespace.Add(e.EventHandlerType.GetMethod("Invoke").GetParameters()[1].ParameterType.Namespace); 
            }
        }

#>
<# foreach(var ns in usingNamespace){#>
using <#=ns#>;
<#}#>

namespace System.Windows.Controls {
    public static class ObservableEventsMixin {

<#foreach (var type in typesToDo) {
 var events=type.GetEvents(
    BindingFlags.DeclaredOnly 
    | BindingFlags.Instance 
    | BindingFlags.Public)
    .Where(x =>{ 
       var addMethod = x.GetAddMethod();
       var basetype = addMethod.GetBaseDefinition().DeclaringType;
       return basetype == type && (!addMethod.IsFinal || basetype.IsInterface);
    }) 
  .ToList(); 
 if(events.Count==0){continue;}
#> 
////////////////////////////////////////////
////////////////////////////////////////////
////   <#= type.Name #>
////////////////////////////////////////////
////////////////////////////////////////////
<#foreach (var eventInfo in events) { #>
<#
var eventType = eventInfo.EventHandlerType.Name; // e.g. MouseEventHandler
var eventName = eventInfo.Name; // e.g. MouseMove
var eventArgs = eventInfo.EventHandlerType.GetMethod("Invoke").GetParameters()[1].ParameterType; // e.g. MouseEventArgs
if (type.IsGenericType){
    continue;
}
if (eventArgs.IsGenericType){
    continue;
}
if (eventInfo.EventHandlerType.IsGenericType)
{
    continue;
    switch (eventInfo.EventHandlerType.Name)
    {
        case "ReturnEventHandler`1":
            eventType = string.Format("ReturnEventHandler<{0}>", eventArgs.Name);
            break;
        case "RoutedPropertyChangedEventHandler`1":
            eventType = string.Format("RoutedPropertyChangedEventHandler<{0}>", eventArgs.Name);
            break;
        case "EventHandler`1":
            eventType = string.Format("EventHandler<{0}>", eventArgs.Name);
            break;
        default:
            throw new Exception("Can't cope with other generic types");
    }
}
#>

        public static IObservable<EventPattern<<#=eventArgs.Name#>>> <#=eventName#>Observer(this <#=type.Name#> This){
            return Observable.FromEventPattern<<#=eventType#>, <#=eventArgs.Name#>>(h => This.<#=eventName#> += h, h => This.<#=eventName#> -= h);
        }
<#}#>
<#}#>

    }
}